This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2024-12-14T15:31:16.851Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repomix, visit: https://github.com/yamadashy/repomix

================================================================
Repository Structure
================================================================
app/
  (tabs)/
    _layout.tsx
    index.tsx
    settings.tsx
    transactions.tsx
  _layout.tsx
  +html.tsx
  +not-found.tsx
  create-transaction.tsx
components/
  button/
    Button.tsx
    LinkButton.tsx
  carousel/
    Carousel.tsx
    CarouselItemChart.tsx
    CarouselItemText.tsx
    CarouselItemWrapper.tsx
  charts/
    BarChart.tsx
    SpendBarChart.tsx
    SpendByCategoryChart.tsx
    SpendByTypeChart.tsx
  checkbox/
    CheckBoxWithLabel.tsx
  filtering/
    BottomSheetWrapper.tsx
    CategoryFilterSection.tsx
    DateFilterOption.tsx
    DateFilterSection.tsx
    FilterOptions.tsx
  settings/
    SettingsItem.tsx
  sheet/
    BottomSheetTextInput.tsx
    constants.ts
    CreateCategorySheet.tsx
    ExportCSVSheet.tsx
    ImportCSVSheet.tsx
    ManageCategoriesSheet.tsx
  CategoriesList.tsx
  CreateExpenseItem.tsx
  CreateFirstTransactionButton.tsx
  CurrencyInput.tsx
  CurrencyItem.tsx
  CurrencySelect.tsx
  CustomBackdrop.tsx
  DatePicker.tsx
  DocumentPicker.tsx
  HomeTransactionsSection.tsx
  InfoItem.tsx
  SpendOverview.tsx
  StyledScrollView.tsx
  Switch.tsx
  TransactionItem.tsx
  TransactionsList.tsx
constants/
  Colors.ts
data/
  currencies.ts
  defaultCategories.ts
  emojis.ts
  transactions.ts
database/
  category-model.ts
  helpers.ts
  index.ts
  migrations.ts
  schema.ts
  transaction-model.ts
hooks/
  useCurrencyApi.ts
  useDefaultCurrency.ts
  useSeedCategories.tsx
  useThemeColor.ts
  useToast.ts
lib/
  date.ts
  format.ts
.gitignore
.nvmrc
.prettierrc
.prettierrc.js
.repomixignore
.yarnrc.yml
app.json
babel.config.js
biome.json
eas.json
eslint.config.mjs
main.d.ts
metro.config.js
package.json
README.md
repomix.config.json
tamagui.config.ts
tsconfig.json

================================================================
Repository Files
================================================================

================
File: app/(tabs)/_layout.tsx
================
import { BottomTabBar } from '@react-navigation/bottom-tabs';
import { CircleDollarSign, Home, Settings } from '@tamagui/lucide-icons';
import { Tabs } from 'expo-router';
import React from 'react';
import { BlurView } from 'expo-blur';
import { useTheme } from 'tamagui';

const CustomTabBar: React.ComponentProps<typeof Tabs>['tabBar'] = props => {
  return (
    <BlurView
      style={{
        position: 'absolute',
        bottom: 0,
        left: 0,
        right: 0,
      }}
      intensity={40}
      tint="dark">
      <BottomTabBar {...props} />
    </BlurView>
  );
};

export default function TabLayout() {
  const { brandPrimary, seashell } = useTheme();
  return (
    <Tabs
      screenOptions={{
        tabBarActiveTintColor: brandPrimary?.val,
        headerShown: false,
        tabBarInactiveTintColor: seashell?.val,
        tabBarStyle: {
          borderTopColor: '#66666666',
          backgroundColor: 'transparent',
          elevation: 0,
        },
      }}
      tabBar={CustomTabBar}>
      <Tabs.Screen
        name="index"
        options={{
          title: 'Home',
          tabBarIcon: ({ color }) => <Home color={color} />,
        }}
      />
      <Tabs.Screen
        name="transactions"
        options={{
          title: 'Transactions',
          tabBarIcon: ({ color }) => <CircleDollarSign color={color} />,
        }}
      />
      <Tabs.Screen
        name="settings"
        options={{
          title: 'Settings',
          tabBarIcon: ({ color }) => <Settings color={color} />,
        }}
      />
    </Tabs>
  );
}

================
File: app/(tabs)/index.tsx
================
import * as React from 'react';
import { useSafeAreaInsets } from 'react-native-safe-area-context';
import { Button, Text, View } from 'tamagui';
import { PlusCircle } from '@tamagui/lucide-icons';
import { useRouter } from 'expo-router';
import { Carousel } from '../../components/carousel/Carousel';
import { useDatabase } from '@nozbe/watermelondb/hooks';
import { HomeTransactionsSection } from '../../components/HomeTransactionsSection';
import { SpendByType } from '../../components/charts/SpendByTypeChart';
import { SpendByCategory } from '../../components/charts/SpendByCategoryChart';
import { useCallback, useState } from 'react';
import { SpendOverview } from '../../components/SpendOverview';
import dayjs from 'dayjs';
import { DatePicker } from '../../components/DatePicker';
import BottomSheetWrapper from '../../components/filtering/BottomSheetWrapper';
import { BottomSheetModal } from '@gorhom/bottom-sheet';

export default function TabTwoScreen() {
  const { top } = useSafeAreaInsets();
  const dateSheetRef = React.useRef<BottomSheetModal | null>(null);
  const [fromDate, setFromDate] = useState<dayjs.Dayjs>(dayjs().startOf('month'));
  const [toDate, setToDate] = useState(dayjs().endOf('month'));
  const [tempFromDate, setTempFromDate] = useState(fromDate);
  const [tempToDate, setTempToDate] = useState(toDate);
  const database = useDatabase();

  const renderCarouselItem = useCallback(
    ({ index }: { index: number }) => {
      if (index === 0) {
        return (
          <SpendOverview
            database={database}
            fromDate={fromDate}
            toDate={toDate}
            onDatePress={() => {
              dateSheetRef.current?.present();
            }}
          />
        );
      }
      if (index === 1) {
        return <SpendByType database={database} type={'expense'} />;
      }
      if (index === 2) {
        return <SpendByType database={database} type={'income'} />;
      }
      if (index === 3) {
        return <SpendByCategory database={database} />;
      }

      return <View />;
    },
    [database, fromDate, toDate]
  );

  const router = useRouter();
  return (
    <>
      <View style={{ paddingTop: top }} backgroundColor={'$bgPrimary'} paddingHorizontal={'$2'}>
        <HomeTransactionsSection
          database={database}
          header={
            <>
              <Text fontSize={'$9'} fontWeight={'bold'} marginBottom={'$2'}>
                Overview
              </Text>
              <Carousel renderItem={renderCarouselItem} data={[...new Array(4).keys()]} />
              <View flexDirection={'row'} gap={'$2'} marginTop={'$4'} width={'100%'}>
                <Button
                  gap={'$0'}
                  paddingHorizontal={'$2'}
                  flex={1}
                  color={'$stroberi'}
                  onPress={() => {
                    router.push({
                      pathname: '/create-transaction',
                      params: {
                        transactionType: 'expense',
                      },
                    });
                  }}>
                  <PlusCircle color={'$stroberi'} size={16} /> Expense
                </Button>
                <Button
                  flex={1}
                  color={'$green'}
                  gap={'$0'}
                  paddingHorizontal={'$2'}
                  onPress={() => {
                    router.push({
                      pathname: '/create-transaction',
                      params: {
                        transactionType: 'income',
                      },
                    });
                  }}>
                  <PlusCircle color={'$green'} size={16} /> Income
                </Button>
              </View>
              <Text fontSize={'$9'} fontWeight={'bold'} marginTop={'$4'} marginBottom={'$2'}>
                Recent Transactions
              </Text>
            </>
          }
        />
      </View>
      <BottomSheetWrapper sheetRef={dateSheetRef}>
        <View paddingHorizontal={'$4'} paddingVertical={'$2'} gap={'$5'}>
          <View flexDirection={'row'} justifyContent={'space-between'} alignItems={'center'}>
            <Text fontSize={'$6'} fontWeight={'bold'}>
              From Date
            </Text>
            <DatePicker date={tempFromDate.toDate()} setDate={d => setTempFromDate(dayjs(d))} />
          </View>
          <View flexDirection={'row'} justifyContent={'space-between'} alignItems={'center'}>
            <Text fontSize={'$6'} fontWeight={'bold'}>
              To Date
            </Text>
            <DatePicker date={tempToDate.toDate()} setDate={d => setTempToDate(dayjs(d))} />
          </View>
          <Button
            backgroundColor={'$green'}
            gap={'$0'}
            paddingHorizontal={'$2'}
            onPress={() => {
              setFromDate(tempFromDate);
              setToDate(tempToDate);
              dateSheetRef.current?.close();
            }}>
            Apply
          </Button>
        </View>
      </BottomSheetWrapper>
    </>
  );
}

================
File: app/(tabs)/settings.tsx
================
import { useSafeAreaInsets } from 'react-native-safe-area-context';
import { ScrollView, Text, View, YGroup } from 'tamagui';
import { DollarSign, FolderInput, FolderOutput, Star, Tags } from '@tamagui/lucide-icons';
import * as React from 'react';
import { SettingsItem } from '../../components/settings/SettingsItem';
import { ManageCategoriesSheet } from '../../components/sheet/ManageCategoriesSheet';
import { BottomSheetModal } from '@gorhom/bottom-sheet';
import { useDefaultCurrency } from '../../hooks/useDefaultCurrency';
import { CurrencySelect } from '../../components/CurrencySelect';
import { ExportCSVSheet } from '../../components/sheet/ExportCSVSheet';
import { ImportCSVSheet } from '../../components/sheet/ImportCSVSheet';

export default function SettingsScreen() {
  const { top } = useSafeAreaInsets();
  const manageCategoriesSheetRef = React.useRef<BottomSheetModal | null>(null);
  const currencySheetRef = React.useRef<BottomSheetModal | null>(null);
  const exportCsvSheetRef = React.useRef<BottomSheetModal | null>(null);
  const importCsvSheetRef = React.useRef<BottomSheetModal | null>(null);
  const { setDefaultCurrency, defaultCurrency } = useDefaultCurrency();
  return (
    <>
      <ScrollView
        style={{ paddingTop: top }}
        backgroundColor={'$bgPrimary'}
        paddingHorizontal={'$2'}>
        <Text fontSize={'$9'} fontWeight={'bold'} marginBottom={'$4'}>
          Settings
        </Text>

        <Text fontSize={'$7'} marginBottom={'$2'}>
          General
        </Text>
        <YGroup>
          <SettingsItem
            label={'Default Currency'}
            IconComponent={DollarSign}
            rightLabel={defaultCurrency ?? 'Select'}
            onPress={() => {
              currencySheetRef.current?.present();
            }}
          />
          <SettingsItem
            label={'Manage Categories'}
            IconComponent={Tags}
            rightLabel={''}
            onPress={() => {
              manageCategoriesSheetRef.current?.present();
            }}
          />
        </YGroup>

        <Text fontSize={'$7'} marginTop="$4" marginBottom={'$2'}>
          Data
        </Text>
        <YGroup>
          <SettingsItem
            label={'CSV Export'}
            IconComponent={FolderOutput}
            rightLabel={''}
            onPress={() => {
              exportCsvSheetRef.current?.present();
            }}
          />
          <SettingsItem
            label={'CSV Import'}
            IconComponent={FolderInput}
            rightLabel={''}
            onPress={() => {
              importCsvSheetRef.current?.present();
            }}
          />
          {/*<SettingsItem*/}
          {/*  label={'Import with Bank Statements'}*/}
          {/*  IconComponent={Landmark}*/}
          {/*  rightLabel={''}*/}
          {/*/>*/}
          {/*<SettingsItem*/}
          {/*  label={'Recurring Transactions'}*/}
          {/*  IconComponent={RefreshCw}*/}
          {/*  rightLabel={''}*/}
          {/*/>*/}
        </YGroup>
        <Text fontSize={'$7'} marginTop="$4" marginBottom={'$2'}>
          Legal
        </Text>
        <YGroup>
          <SettingsItem label={'Privacy Policy'} />
          <SettingsItem label={'Terms of Service'} />
        </YGroup>
        <Text fontSize={'$7'} marginTop="$4" marginBottom={'$2'}>
          Support
        </Text>
        <YGroup>
          <SettingsItem label={'Rate App'} IconComponent={Star} rightLabel={''} />
        </YGroup>
        <View height={140} />
      </ScrollView>
      <ManageCategoriesSheet sheetRef={manageCategoriesSheetRef} noSearch />
      <CurrencySelect
        sheetRef={currencySheetRef}
        onSelect={currency => {
          setDefaultCurrency(currency.code);
          currencySheetRef.current?.close();
        }}
        selectedCurrency={defaultCurrency ?? 'USD'}
      />
      <ExportCSVSheet sheetRef={exportCsvSheetRef} />
      <ImportCSVSheet sheetRef={importCsvSheetRef} />
    </>
  );
}

================
File: app/(tabs)/transactions.tsx
================
import { useSafeAreaInsets } from 'react-native-safe-area-context';
import { Text, View } from 'tamagui';
import * as React from 'react';
import { Filter } from '@tamagui/lucide-icons';
import { LinkButton } from '../../components/button/LinkButton';
import { useDatabase } from '@nozbe/watermelondb/hooks';
import dayjs from 'dayjs';
import isToday from 'dayjs/plugin/isToday';
import isYesterday from 'dayjs/plugin/isYesterday';
import TransactionsList from '../../components/TransactionsList';
import { DatePicker } from '../../components/DatePicker';
import { useState } from 'react';
import { Button } from '../../components/button/Button';
import DateFilterSection from '../../components/filtering/DateFilterSection';
import BottomSheetWrapper from '../../components/filtering/BottomSheetWrapper';
import { BottomSheetModal } from '@gorhom/bottom-sheet';
import CategoryFilterSection from '../../components/filtering/CategoryFilterSection';
import { CategoryModel } from '../../database/category-model';

dayjs.extend(isToday);
dayjs.extend(isYesterday);

export type DateFilters = 'This Year' | 'This Month' | 'Custom';

export default function TransactionsScreen() {
  const { top } = useSafeAreaInsets();
  const [dateFilter, setDateFilter] = useState<DateFilters | null>(null);
  const [selectedCategories, setSelectedCategories] = useState<CategoryModel[]>([]);
  const sheetRef = React.useRef<BottomSheetModal>(null);
  const dateSheetRef = React.useRef<BottomSheetModal>(null);
  const database = useDatabase();
  const [fromDate, setFromDate] = useState(new Date());
  const [toDate, setToDate] = useState(new Date());

  const appliedNumberOfFilters = [dateFilter, selectedCategories.length].filter(Boolean).length;
  return (
    <>
      <View
        style={{ paddingTop: top }}
        flex={1}
        backgroundColor={'$bgPrimary'}
        paddingHorizontal={'$2'}>
        <View flexDirection={'row'} justifyContent={'space-between'} alignItems={'center'}>
          <Text fontSize={'$9'} fontWeight={'bold'} marginBottom={'$2'}>
            Transactions
          </Text>
          <LinkButton paddingHorizontal={'$2'} onPress={() => sheetRef.current?.present()}>
            <Filter size={'$1'} color={'$stroberi'} />
            {appliedNumberOfFilters > 0 && (
              <Text color={'$stroberi'} fontWeight={'bold'}>
                +{appliedNumberOfFilters}
              </Text>
            )}
          </LinkButton>
        </View>
        <TransactionsList
          database={database}
          dateFilter={dateFilter}
          customRange={dateFilter === 'Custom' ? [fromDate, toDate] : undefined}
          categories={selectedCategories}
        />
        <View height={140} />
      </View>
      <BottomSheetWrapper sheetRef={sheetRef}>
        <DateFilterSection
          dateFilter={dateFilter}
          setDateFilter={setDateFilter}
          fromDate={fromDate}
          toDate={toDate}
          dateSheetRef={dateSheetRef}
        />
        <CategoryFilterSection
          selectedCategories={selectedCategories}
          setSelectedCategory={setSelectedCategories}
        />
      </BottomSheetWrapper>
      <BottomSheetWrapper sheetRef={dateSheetRef}>
        <View paddingHorizontal={'$4'} paddingVertical={'$2'} gap={'$5'}>
          <View flexDirection={'row'} justifyContent={'space-between'} alignItems={'center'}>
            <Text fontSize={'$6'} fontWeight={'bold'}>
              From Date
            </Text>
            <DatePicker date={fromDate} setDate={setFromDate} />
          </View>
          <View flexDirection={'row'} justifyContent={'space-between'} alignItems={'center'}>
            <Text fontSize={'$6'} fontWeight={'bold'}>
              To Date
            </Text>
            <DatePicker date={toDate} setDate={setToDate} />
          </View>
          <Button
            backgroundColor={'$green'}
            gap={'$0'}
            paddingHorizontal={'$2'}
            onPress={() => {
              dateSheetRef.current?.close();
              setDateFilter('Custom');
            }}>
            Apply
          </Button>
        </View>
      </BottomSheetWrapper>
    </>
  );
}

================
File: app/_layout.tsx
================
import { Stack } from 'expo-router';
import * as SplashScreen from 'expo-splash-screen';
import { ActionSheetProvider } from '@expo/react-native-action-sheet';

import { TamaguiProvider } from 'tamagui';
import { KeyboardProvider } from 'react-native-keyboard-controller';
import { BottomSheetModalProvider } from '@gorhom/bottom-sheet';
import '../tamagui-web.css';

import config from '../tamagui.config';
import { useFonts } from 'expo-font';
import { useEffect } from 'react';
import { GestureHandlerRootView } from 'react-native-gesture-handler';
import { database } from '../database';
import { DatabaseProvider } from '@nozbe/watermelondb/react';
import { useDefaultCurrency } from '../hooks/useDefaultCurrency';
import { useSeedCategories } from '../hooks/useSeedCategories';

export {
  // Catch any errors thrown by the Layout component.
  ErrorBoundary,
} from 'expo-router';

export const unstable_settings = {
  // Ensure that reloading on `/modal` keeps a back button present.
  initialRouteName: '(tabs)',
};

// Prevent the splash screen from auto-hiding before asset loading is complete.
SplashScreen.preventAutoHideAsync();
SplashScreen.setOptions({
  duration: 500,
  fade: true,
});
export default function RootLayout() {
  const [interLoaded, interError] = useFonts({
    Inter: require('@tamagui/font-inter/otf/Inter-Medium.otf'),
    InterBold: require('@tamagui/font-inter/otf/Inter-Bold.otf'),
  });

  useEffect(() => {
    if (interLoaded || interError) {
      // Hide the splash screen after the fonts have loaded (or an error was returned) and the UI is ready.
      SplashScreen.hideAsync();
    }
  }, [interLoaded, interError]);

  useDefaultCurrency();
  useSeedCategories();

  if (!interLoaded && !interError) {
    return null;
  }

  return <RootLayoutNav />;
}

function RootLayoutNav() {
  return (
    <GestureHandlerRootView style={style}>
      <KeyboardProvider>
        <TamaguiProvider config={config} defaultTheme={'dark'}>
          <ActionSheetProvider>
            <DatabaseProvider database={database}>
              <BottomSheetModalProvider>
                <Stack>
                  <Stack.Screen name="(tabs)" options={tabsOptions} />
                  <Stack.Screen name="create-transaction" options={options} />
                </Stack>
              </BottomSheetModalProvider>
            </DatabaseProvider>
          </ActionSheetProvider>
        </TamaguiProvider>
      </KeyboardProvider>
    </GestureHandlerRootView>
  );
}

const style = { flex: 1 };

const options = {
  presentation: 'modal',
  header: () => null,
} as const;

const tabsOptions = {
  headerShown: false,
};

================
File: app/+html.tsx
================
import { ScrollViewStyleReset } from 'expo-router/html';

// This file is web-only and used to configure the root HTML for every
// web page during static rendering.
// The contents of this function only run in Node.js environments and
// do not have access to the DOM or browser APIs.
export default function Root({ children }: { children: React.ReactNode }) {
  return (
    <html lang="en">
      <head>
        <meta charSet="utf-8" />
        <meta httpEquiv="X-UA-Compatible" content="IE=edge" />

        {/* 
          This viewport disables scaling which makes the mobile website act more like a native app.
          However this does reduce built-in accessibility. If you want to enable scaling, use this instead:
            <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover" />
        */}
        <meta
          name="viewport"
          content="width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1.00001,viewport-fit=cover"
        />
        {/* 
          Disable body scrolling on web. This makes ScrollView components work closer to how they do on native. 
          However, body scrolling is often nice to have for mobile web. If you want to enable it, remove this line.
        */}
        <ScrollViewStyleReset />

        {/* Using raw CSS styles as an escape-hatch to ensure the background color never flickers in dark-mode. */}
        <style dangerouslySetInnerHTML={{ __html: responsiveBackground }} />
        {/* Add any additional <head> elements that you want globally available on web... */}
      </head>
      <body>{children}</body>
    </html>
  );
}

const responsiveBackground = `
body {
  background-color: #fff;
}
@media (prefers-color-scheme: dark) {
  body {
    background-color: #000;
  }
}`;

================
File: app/+not-found.tsx
================
import { Link, Stack } from 'expo-router';
import { StyleSheet } from 'react-native';
import { View, Text } from 'tamagui';

export default function NotFoundScreen() {
  return (
    <>
      <Stack.Screen options={{ title: 'Oops!' }} />
      <View margin={10}>
        <Text>This screen doesn't exist.</Text>
        <Link href="/" style={styles.link}>
          <Text style={styles.linkText}>Go to home screen!</Text>
        </Link>
      </View>
    </>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    alignItems: 'center',
    justifyContent: 'center',
    padding: 20,
  },
  title: {
    fontSize: 20,
    fontWeight: 'bold',
  },
  link: {
    marginTop: 15,
    paddingVertical: 15,
  },
  linkText: {
    fontSize: 14,
    color: '#2e78b7',
  },
});

================
File: app/create-transaction.tsx
================
import { Input, Text, TextArea, View, YGroup } from 'tamagui';
import { LinkButton } from '../components/button/LinkButton';
import { CurrencyInput } from '../components/CurrencyInput';
import { ArrowLeft, Calendar, ChevronRight, Clock, LayoutGrid, User } from '@tamagui/lucide-icons';
import { Keyboard } from 'react-native';
import { BottomSheetModal, BottomSheetModalProvider } from '@gorhom/bottom-sheet';
import React, { useEffect, useRef, useState } from 'react';
import { useLocalSearchParams, useRouter } from 'expo-router';
import { DatePicker } from '../components/DatePicker';
import { StyledScrollView } from '../components/StyledScrollView';
import { CreateExpenseItem } from '../components/CreateExpenseItem';
import { CategoryModel } from '../database/category-model';
import { createTransaction, updateTransaction } from '../database/helpers';
import { ManageCategoriesSheet } from '../components/sheet/ManageCategoriesSheet';
import { CurrencySelect } from '../components/CurrencySelect';
import { useDefaultCurrency } from '../hooks/useDefaultCurrency';
import { TransactionModel } from '../database/transaction-model';

function CreateTransaction() {
  const bottomSheetRef = useRef<BottomSheetModal | null>(null);
  const manageCategoriesSheetRef = useRef<BottomSheetModal | null>(null);
  const params = useLocalSearchParams();
  const router = useRouter();

  const transactionType = params.transactionType as 'expense' | 'income';
  const transaction: TransactionModel | null = params.transaction
    ? JSON.parse(params.transaction as string)
    : null;
  const category: CategoryModel | null = params.category
    ? JSON.parse(params.category as string)
    : null;

  const { defaultCurrency } = useDefaultCurrency();

  const [selectedCategory, setSelectedCategory] = useState<CategoryModel | null>(category ?? null);
  const [selectedCurrency, setSelectedCurrency] = useState(transaction?.currencyCode ?? 'USD');
  const [amount, setAmount] = useState(
    `${transactionType ? (transactionType === 'expense' ? '-' : '') : ''}${transaction?.amount ?? ''}`
  );
  const [note, setNote] = useState(transaction?.note ?? '');
  const [merchantName, setMerchantName] = useState(transaction?.merchant ?? '');
  const [date, setDate] = useState(transaction?.date ? new Date(transaction.date) : new Date());

  const handleSubmit = async () => {
    if (!defaultCurrency) {
      return;
    }
    const payload = {
      merchant: merchantName,
      amount: Number(amount),
      categoryId: selectedCategory?.id ?? null,
      date,
      currencyCode: selectedCurrency,
      note,
      baseCurrency: defaultCurrency,
    };
    if (transaction) {
      updateTransaction({
        id: transaction.id,
        ...payload,
      }).then(() => {
        router.back();
      });
    } else {
      createTransaction(payload).then(() => {
        router.back();
      });
    }
  };

  useEffect(() => {
    !transaction?.currencyCode && defaultCurrency && setSelectedCurrency(defaultCurrency);
  }, [defaultCurrency, transaction?.currencyCode]);

  return (
    <BottomSheetModalProvider>
      <StyledScrollView keyboardShouldPersistTaps={'handled'}>
        <View flexDirection={'row'} justifyContent={'space-between'} alignItems={'center'}>
          <LinkButton
            backgroundColor={'transparent'}
            paddingHorizontal={'$2'}
            color={'gray'}
            onPress={() => router.back()}>
            <ArrowLeft size={20} color={'gray'} />
            Back
          </LinkButton>
          <LinkButton color={'white'} backgroundColor={'$green'} onPress={handleSubmit}>
            Save
          </LinkButton>
        </View>
        <View mt={'$8'}>
          <CurrencyInput
            onCurrencySelect={() => bottomSheetRef.current?.present()}
            selectedCurrency={selectedCurrency}
            value={amount}
            onChangeText={setAmount}
            focusOnMount={!transaction}
          />
        </View>

        <YGroup bordered mt={'$4'}>
          <CreateExpenseItem IconComponent={Calendar} label={'Date'}>
            <DatePicker mode={'date'} date={date} setDate={setDate} />
          </CreateExpenseItem>
          <CreateExpenseItem IconComponent={Clock} label={'Time'}>
            <DatePicker mode={'time'} date={date} setDate={setDate} />
          </CreateExpenseItem>
          <CreateExpenseItem IconComponent={User} label={'Merchant/Payee'}>
            <Input
              placeholder={'Enter merchant name'}
              flex={1}
              fontSize={'$2'}
              value={merchantName}
              onChangeText={setMerchantName}
            />
          </CreateExpenseItem>
          <CreateExpenseItem IconComponent={LayoutGrid} label={'Category'}>
            <LinkButton
              color={'white'}
              onPress={() => {
                Keyboard.dismiss();
                manageCategoriesSheetRef.current?.present();
              }}>
              {selectedCategory ? (
                <View flexDirection={'row'} alignItems={'center'} gap={'$2'}>
                  <Text>{selectedCategory.icon}</Text>
                  <Text>{selectedCategory.name} </Text>
                  <ChevronRight color={'white'} size={18} />
                </View>
              ) : (
                <View flexDirection={'row'} alignItems={'center'} gap={'$2'}>
                  <Text>Uncategorized</Text>
                  <ChevronRight color={'white'} size={18} />
                </View>
              )}
            </LinkButton>
          </CreateExpenseItem>
        </YGroup>
        <View mt={'$4'}>
          <TextArea placeholder={'Enter a note'} size={'$5'} value={note} onChangeText={setNote} />
        </View>
      </StyledScrollView>
      <CurrencySelect
        sheetRef={bottomSheetRef}
        onSelect={currency => {
          setSelectedCurrency(currency.code);
          bottomSheetRef.current?.close();
        }}
        selectedCurrency={selectedCurrency}
      />
      <ManageCategoriesSheet
        selectedCategory={selectedCategory}
        setSelectedCategory={setSelectedCategory}
        sheetRef={manageCategoriesSheetRef}
      />
    </BottomSheetModalProvider>
  );
}

export default CreateTransaction;

================
File: components/button/Button.tsx
================
import { Button as TamaguiButton } from 'tamagui';
import { styled } from '@tamagui/core';

const Button = styled(TamaguiButton, {
  fontSize: '$5',
  fontWeight: 'bold',
  variants: {
    brand: {
      primary: {
        backgroundColor: '$primary',
        color: '$white',
      },
      secondary: {
        backgroundColor: '$secondary',
        color: '$white',
      },
    },
  },
});
export { Button };

================
File: components/button/LinkButton.tsx
================
import { Button, styled } from 'tamagui';

export const LinkButton = styled(Button, {
  alignSelf: 'flex-start',
  backgroundColor: '$gray',
  color: '$stroberi',
  borderRadius: '$10',
  paddingVertical: '$0',
  paddingHorizontal: '$4',
  height: 36,
  fontSize: '$5',
});

================
File: components/carousel/Carousel.tsx
================
import * as React from 'react';
import { useSharedValue } from 'react-native-reanimated';
import CarouselComp, { ICarouselInstance, Pagination } from 'react-native-reanimated-carousel';
import { useWindowDimensions, View } from 'tamagui';
import { ReactElement } from 'react';

const colors = ['#26292E', '#26292E', '#26292E', '#26292E', '#26292E', '#26292E'];

type CarouselProps = {
  renderItem: ({ index }: { index: number }) => ReactElement;
  data: number[];
};
export function Carousel({ renderItem, data }: CarouselProps) {
  const progress = useSharedValue<number>(0);
  const { width } = useWindowDimensions();
  const baseOptions = {
    vertical: false,
    width: width,
    height: width * 0.6,
  } as const;

  const ref = React.useRef<ICarouselInstance>(null);

  const onPressPagination = (index: number) => {
    ref.current?.scrollTo({
      /**
       * Calculate the difference between the current index and the target index
       * to ensure that the carousel scrolls to the nearest index
       */
      count: index - progress.value,
      animated: true,
    });
  };

  return (
    <>
      <CarouselComp
        {...baseOptions}
        loop
        ref={ref}
        width={width - 16}
        height={width / 1.5}
        data={data}
        scrollAnimationDuration={1000}
        pagingEnabled
        snapEnabled
        autoPlay={false}
        onProgressChange={progress}
        mode="parallax"
        modeConfig={{
          parallaxScrollingScale: 1,
          parallaxScrollingOffset: 5,
        }}
        renderItem={renderItem}
      />
      <Pagination.Basic<{ color: string }>
        progress={progress}
        data={new Array(data.length).fill({
          color: colors[0],
        })}
        size={12}
        dotStyle={{
          borderRadius: 100,
          backgroundColor: 'rgba(73,72,72,0.4)',
        }}
        activeDotStyle={{
          borderRadius: 100,
          overflow: 'hidden',
        }}
        containerStyle={{
          gap: 14,
          marginTop: 14,
        }}
        horizontal
        renderItem={item => (
          <View
            style={{
              backgroundColor: item.color,
              flex: 1,
            }}
          />
        )}
        onPress={onPressPagination}
      />
    </>
  );
}

================
File: components/carousel/CarouselItemChart.tsx
================
import { View } from 'tamagui';
import * as React from 'react';

type CarouselItemChartProps = {
  children: React.ReactNode;
};
export const CarouselItemChart = ({ children }: CarouselItemChartProps) => {
  return (
    <View backgroundColor={'transparent'} height={200}>
      {children}
    </View>
  );
};

================
File: components/carousel/CarouselItemText.tsx
================
import { Text } from 'tamagui';
import * as React from 'react';

type CarouselItemTextProps = {
  children: React.ReactNode;
} & React.ComponentProps<typeof Text>;
export const CarouselItemText = ({ children, ...rest }: CarouselItemTextProps) => {
  return (
    <Text fontSize={'$4'} fontWeight={'bold'} {...rest}>
      {children}
    </Text>
  );
};

================
File: components/carousel/CarouselItemWrapper.tsx
================
import { View } from 'tamagui';
import * as React from 'react';

type CarouselItemWrapperProps = {
  children: React.ReactNode;
};
export const CarouselItemWrapper = ({ children }: CarouselItemWrapperProps) => {
  return (
    <View
      borderRadius={'$4'}
      marginRight={'$2'}
      marginLeft={'$2'}
      backgroundColor={'$gray4'}
      paddingVertical={'$3'}
      paddingBottom={'$4'}>
      {children}
    </View>
  );
};

================
File: components/charts/BarChart.tsx
================
import { Bar, CartesianChart, ChartPressState } from 'victory-native';
import { LinearGradient, useFont, vec, Circle } from '@shopify/react-native-skia';
import inter from '../../assets/fonts/Inter-Medium.ttf';
import React from 'react';
import type { InputFields, NumericalFields } from 'victory-native/dist/types';
import type { SharedValue } from 'react-native-reanimated';

type CartesianChartProps<
  RawData extends Record<string, unknown>,
  XK extends keyof InputFields<RawData>,
  YK extends keyof NumericalFields<RawData>,
> = {
  data: RawData[];
  xKey: XK;
  yKeys: YK[];
  domainPadding?: {
    left?: number;
    right?: number;
    top?: number;
    bottom?: number;
  };
  barWidth?: number;
  state?:
    | ChartPressState<{ x: InputFields<RawData>[XK]; y: Record<YK, number> }>
    | ChartPressState<{ x: InputFields<RawData>[XK]; y: Record<YK, number> }>[];
  isActive?: boolean;
  tooltip?: {
    ttX: SharedValue<number>;
    ttY: SharedValue<number>;
  };
  barCount?: number;
};

export const BarChart = <
  RawData extends Record<string, unknown>,
  XK extends keyof InputFields<RawData>,
  YK extends keyof NumericalFields<RawData>,
>({
  data,
  yKeys,
  xKey,
  domainPadding = { left: 32, right: 32, top: 0, bottom: 0 },
  barWidth,
  state,
  isActive,
  tooltip,
  barCount,
}: CartesianChartProps<RawData, XK, YK>) => {
  const font = useFont(inter, 12);

  return (
    <CartesianChart<RawData, XK, YK>
      data={data}
      xKey={xKey}
      yKeys={yKeys}
      domainPadding={domainPadding}
      chartPressState={state}
      padding={{
        right: 8,
        left: 8,
        bottom: 8,
      }}
      chartPressConfig={{
        pan: {
          activateAfterLongPress: 200,
        },
      }}
      axisOptions={{
        font,
        labelColor: 'white',
        formatXLabel: x => (x ? x.toString() : ''),
      }}>
      {({ points, chartBounds }) => (
        <>
          <Bar
            chartBounds={chartBounds}
            points={points[yKeys[0]]}
            barWidth={barWidth}
            barCount={barCount}
            roundedCorners={{
              topLeft: 5,
              topRight: 5,
            }}>
            <LinearGradient start={vec(0, 0)} end={vec(0, 400)} colors={['white', 'black']} />
          </Bar>
          {isActive && tooltip && <ToolTip x={tooltip.ttX} y={tooltip.ttY} />}
        </>
      )}
    </CartesianChart>
  );
};

function ToolTip({ x, y }: { x: SharedValue<number>; y: SharedValue<number> }) {
  return <Circle cx={x} cy={y} r={8} color={'grey'} opacity={0.8} />;
}

================
File: components/charts/SpendBarChart.tsx
================
import { useDefaultCurrency } from '../../hooks/useDefaultCurrency';
import { useChartPressState } from 'victory-native';
import {
  useAnimatedReaction,
  useDerivedValue,
  useSharedValue,
  withTiming,
} from 'react-native-reanimated';
import { formatCurrencyWorklet } from '../../lib/format';
import { Canvas, matchFont, Text } from '@shopify/react-native-skia';
import { CarouselItemWrapper } from '../carousel/CarouselItemWrapper';
import { View } from 'tamagui';
import { CarouselItemText } from '../carousel/CarouselItemText';
import { CarouselItemChart } from '../carousel/CarouselItemChart';
import { CircleSlash } from '@tamagui/lucide-icons';
import { BarChart } from './BarChart';
import * as React from 'react';
import type { InputFields, NumericalFields } from 'victory-native/dist/types';

const animConfig = { duration: 300 };

type SpendBarChartProps<
  RawData extends Record<string, unknown>,
  XK extends keyof InputFields<RawData>,
  YK extends keyof NumericalFields<RawData>,
> = {
  chartData: RawData[];
  title: string;
  xKey: XK;
  yKeys: YK[];
  isEmpty: boolean;
  barCount?: number;
  barWidth?: number;
};

export const SpendBarChart = <
  RawData extends Record<string, unknown>,
  XK extends keyof InputFields<RawData>,
  YK extends keyof NumericalFields<RawData>,
>({
  chartData,
  title,
  xKey,
  yKeys,
  isEmpty,
  barCount,
  barWidth,
}: SpendBarChartProps<RawData, XK, YK>) => {
  const { defaultCurrency } = useDefaultCurrency();
  const { state, isActive } = useChartPressState({
    x: xKey as string,
    y: yKeys.reduce((acc, key) => ({ ...acc, [key]: 0 }), {} as Record<string, number>),
  });
  const amount = useDerivedValue(() => {
    const formattedCurrency = formatCurrencyWorklet(
      state?.y.total.value.value,
      defaultCurrency ?? 'USD'
    );
    return `${state.x.value.value}: ${formattedCurrency}`;
  }, [state?.y.total.value.value]);

  const fontStyle = {
    fontFamily: 'Inter',
    fontSize: 14,
    fontWeight: 'bold' as const,
  };
  const font = matchFont(fontStyle);

  const ttX = useSharedValue(0);
  const ttY = useSharedValue(0);

  useAnimatedReaction(
    () => state?.x.position.value,
    val => {
      ttX.value = withTiming(val, animConfig);
    }
  );
  useAnimatedReaction(
    () => state?.y.total.position.value,
    val => {
      ttY.value = withTiming(val, animConfig);
    }
  );

  return (
    <CarouselItemWrapper>
      <View
        flexDirection={'row'}
        alignItems={'center'}
        justifyContent={'space-between'}
        paddingHorizontal={'$2'}
        marginBottom={'$2'}>
        {isActive ? (
          <Canvas
            style={{
              height: 17,
              flex: 1,
            }}>
            <Text x={0} y={12} font={font} text={amount} color={'white'} style={'fill'} />
          </Canvas>
        ) : (
          <CarouselItemText>{title}</CarouselItemText>
        )}
      </View>
      <CarouselItemChart>
        {isEmpty ? (
          <View width={'100%'} height="100%" alignItems={'center'} justifyContent={'center'}>
            <CarouselItemText color={'darkgray'}>No data available</CarouselItemText>
            <CircleSlash size={64} color={'darkgray'} />
          </View>
        ) : (
          <BarChart
            xKey={xKey}
            yKeys={yKeys}
            data={chartData}
            // @ts-expect-error ignore for now
            state={state}
            isActive={isActive}
            tooltip={{
              ttX,
              ttY,
            }}
            barCount={barCount}
            barWidth={barWidth}
          />
        )}
      </CarouselItemChart>
    </CarouselItemWrapper>
  );
};

================
File: components/charts/SpendByCategoryChart.tsx
================
import { withObservables } from '@nozbe/watermelondb/react';
import { Database, Q } from '@nozbe/watermelondb';
import { map, Observable } from 'rxjs';
import { TransactionModel } from '../../database/transaction-model';
import * as React from 'react';
import { CategoryModel } from '../../database/category-model';
import { useWindowDimensions } from 'tamagui';
import { useDefaultCurrency } from '../../hooks/useDefaultCurrency';
import { SpendBarChart } from './SpendBarChart';

type SpendByCategoryProps = {
  chartData: SpendByCategoryChartData;
  categories: CategoryModel[];
};
type SpendByCategoryChartData = {
  category: string;
  total: number;
}[];
export const SpendByCategory = withObservables<
  { database: Database },
  {
    chartData: Observable<SpendByCategoryChartData>;
    categories: Observable<CategoryModel[]>;
  }
>([], ({ database }) => {
  return {
    categories: database.collections.get<CategoryModel>('categories').query().observe(),
    chartData: database.collections
      .get<TransactionModel>('transactions')
      .query(Q.where('amountInBaseCurrency', Q.lt(0)))
      .observe()
      .pipe(
        map(transactions => {
          const categories = transactions.reduce(
            (acc, transaction) => {
              const category = transaction.category?.id || 'Uncategorized';
              if (!acc[category]) {
                acc[category] = 0;
              }
              acc[category] += Math.abs(transaction.amountInBaseCurrency);
              return acc;
            },
            {} as Record<string, number>
          );

          return Object.entries(categories).map(([category, total]) => ({
            category,
            total,
          }));
        })
      ),
  };
})(({ chartData, categories }: SpendByCategoryProps) => {
  const data = chartData
    .map(({ category, total }) => ({
      category,
      total,
      categoryName: categories.find(c => c.id === category)?.name || 'Uncategorized',
    }))
    .sort((a, b) => b.total - a.total)
    .slice(0, 5);

  const dimensions = useWindowDimensions();
  const totalBars = data.length;
  const { defaultCurrency } = useDefaultCurrency();
  return (
    <SpendBarChart
      chartData={data}
      title={`Top spend by category (${defaultCurrency})`}
      xKey={'categoryName'}
      yKeys={['total']}
      isEmpty={data.length === 0}
      barCount={totalBars}
      barWidth={totalBars > 0 ? Math.min(dimensions.width / totalBars - 40, 60) : 0}
    />
  );
});

================
File: components/charts/SpendByTypeChart.tsx
================
import { withObservables } from '@nozbe/watermelondb/react';
import { Database, Q } from '@nozbe/watermelondb';
import { map, Observable } from 'rxjs';
import { TransactionModel } from '../../database/transaction-model';
import * as React from 'react';
import dayjs from 'dayjs';
import { useDefaultCurrency } from '../../hooks/useDefaultCurrency';
import { SpendBarChart } from './SpendBarChart';

type SpendByMonthProps = {
  chartData: SpendByMonthChartData;
  type: 'expense' | 'income';
};
export type SpendByMonthChartData = {
  month: string;
  year: number;
  total: number;
}[];
export const SpendByType = withObservables<
  { database: Database; type: 'expense' | 'income' },
  {
    chartData: Observable<SpendByMonthChartData>;
  }
>(['type'], ({ database, type }) => {
  return {
    chartData: database.collections
      .get<TransactionModel>('transactions')
      .query(Q.where('amountInBaseCurrency', type === 'income' ? Q.gte(0) : Q.lt(0)))
      .observe()
      .pipe(
        map(transactions => {
          const last6Months = Array.from({ length: 6 }, (_, i) => {
            return dayjs().subtract(i, 'month').toDate();
          }).reverse();

          return last6Months.map(date => {
            const month = date.toLocaleString('default', { month: 'short' });
            const year = date.getFullYear();
            const total = transactions
              .filter(transaction => {
                const transactionDate = new Date(transaction.date);
                return (
                  transactionDate.getMonth() === date.getMonth() &&
                  transactionDate.getFullYear() === date.getFullYear()
                );
              })
              .reduce((acc, transaction) => acc + Math.abs(transaction.amountInBaseCurrency), 0);
            return {
              month,
              year,
              total,
            };
          });
        })
      ),
  };
})(({ chartData, type }: SpendByMonthProps) => {
  const { defaultCurrency } = useDefaultCurrency();
  return (
    <SpendBarChart
      chartData={chartData}
      title={
        type === 'expense'
          ? `Spend by Month (${defaultCurrency})`
          : `Income by Month (${defaultCurrency})`
      }
      isEmpty={chartData.every(el => el.total === 0)}
      xKey={'month'}
      yKeys={['total']}
    />
  );
});

================
File: components/checkbox/CheckBoxWithLabel.tsx
================
import { Checkbox, CheckboxProps, Label, XStack } from 'tamagui';
import { Check as CheckIcon } from '@tamagui/lucide-icons';
import React from 'react';

export function CheckboxWithLabel({
  size,
  name,
  label,
  ...checkboxProps
}: CheckboxProps & { label: string; name: string }) {
  return (
    <XStack alignItems="center" gap="$3">
      <Checkbox id={name} size={size} {...checkboxProps}>
        <Checkbox.Indicator>
          <CheckIcon />
        </Checkbox.Indicator>
      </Checkbox>
      <Label size={size} htmlFor={name}>
        {label}
      </Label>
    </XStack>
  );
}

================
File: components/filtering/BottomSheetWrapper.tsx
================
import React from 'react';
import { BottomSheetModal, BottomSheetView } from '@gorhom/bottom-sheet';

import { useSafeAreaInsets } from 'react-native-safe-area-context';
import { CustomBackdrop } from '../CustomBackdrop';
import { backgroundStyle, handleIndicatorStyle } from '../sheet/constants';

type BottomSheetWrapperProps = {
  sheetRef: React.RefObject<BottomSheetModal>;
  children: React.ReactNode;
} & React.ComponentProps<typeof BottomSheetModal>;

const BottomSheetWrapper = ({ sheetRef, children, ...rest }: BottomSheetWrapperProps) => {
  const { bottom } = useSafeAreaInsets();
  return (
    <BottomSheetModal
      ref={sheetRef}
      enableDynamicSizing={true}
      backdropComponent={CustomBackdrop}
      stackBehavior="push"
      handleIndicatorStyle={handleIndicatorStyle}
      backgroundStyle={backgroundStyle}
      {...rest}>
      <BottomSheetView style={{ paddingBottom: bottom + 16 }}>{children}</BottomSheetView>
    </BottomSheetModal>
  );
};

export default BottomSheetWrapper;

================
File: components/filtering/CategoryFilterSection.tsx
================
import React, { useRef } from 'react';
import { View, Text } from 'tamagui';
import { PlusCircle, XCircle } from '@tamagui/lucide-icons';
import { LinkButton } from '../button/LinkButton';
import { BottomSheetModal } from '@gorhom/bottom-sheet';
import { ManageCategoriesSheet } from '../sheet/ManageCategoriesSheet';
import FilterOption from './FilterOptions';
import { CategoryModel } from '../../database/category-model';

type CategoryFilterSectionProps = {
  selectedCategories: CategoryModel[];
  setSelectedCategory: (category: CategoryModel[]) => void;
};

const CategoryFilterSection = ({
  selectedCategories,
  setSelectedCategory,
}: CategoryFilterSectionProps) => {
  const manageCategoriesSheetRef = useRef<BottomSheetModal>(null);
  const handleCategoryPress = (category: CategoryModel) => {
    if (selectedCategories.some(c => c.id === category.id)) {
      setSelectedCategory(selectedCategories.filter(cat => cat.id !== category.id));
    } else {
      setSelectedCategory([...selectedCategories, category]);
    }
  };

  return (
    <View paddingHorizontal={'$4'} paddingVertical={'$2'}>
      <View flexDirection={'row'} justifyContent={'space-between'} alignItems={'center'} mb={'$4'}>
        <Text fontSize={'$6'} fontWeight={'bold'} marginBottom={'$2'}>
          Filter by Category
        </Text>
        {selectedCategories.length > 0 && (
          <LinkButton onPress={() => setSelectedCategory([])}>
            <XCircle size={18} color={'white'} />
          </LinkButton>
        )}
      </View>
      <View flexDirection={'row'} gap={'$3'} flexWrap={'wrap'}>
        {selectedCategories?.map(category => (
          <FilterOption
            key={category.id}
            label={category.name}
            icon={category.icon}
            isSelected={selectedCategories?.some(c => c.id === category.id) ?? false}
            onPress={() => handleCategoryPress(category)}
          />
        ))}
        <LinkButton
          paddingHorizontal={'$4'}
          onPress={() => manageCategoriesSheetRef.current?.present()}>
          <PlusCircle size={18} color={'white'} />
          <Text>Add Category</Text>
        </LinkButton>
      </View>

      <ManageCategoriesSheet
        preventClose
        selectedCategories={selectedCategories}
        sheetRef={manageCategoriesSheetRef}
        setSelectedCategory={category => {
          handleCategoryPress(category);
        }}
      />
    </View>
  );
};

export default CategoryFilterSection;

================
File: components/filtering/DateFilterOption.tsx
================
import React from 'react';
import { Text } from 'tamagui';

import { Check } from '@tamagui/lucide-icons';
import { LinkButton } from '../button/LinkButton';

type DateFilterOptionProps = {
  label: string;
  isSelected: boolean;
  onPress: () => void;
};

const DateFilterOption = ({ label, isSelected, onPress }: DateFilterOptionProps) => (
  <LinkButton
    paddingHorizontal={'$4'}
    onPress={onPress}
    backgroundColor={isSelected ? '$green' : '$background075'}>
    <Text>{label}</Text>
    {isSelected && <Check size={12} color={'white'} />}
  </LinkButton>
);

export default DateFilterOption;

================
File: components/filtering/DateFilterSection.tsx
================
import React from 'react';
import { View, Text } from 'tamagui';
import { XCircle } from '@tamagui/lucide-icons';
import dayjs from 'dayjs';
import DateFilterOption from './DateFilterOption';
import { LinkButton } from '../button/LinkButton';
import { BottomSheetModal } from '@gorhom/bottom-sheet';
import { DateFilters } from '../../app/(tabs)/transactions';

type DateFilterSectionProps = {
  dateFilter: string | null;
  setDateFilter: React.Dispatch<React.SetStateAction<DateFilters | null>>;
  fromDate: Date;
  toDate: Date;
  dateSheetRef: React.RefObject<BottomSheetModal>;
};

const DateFilterSection = ({
  dateFilter,
  setDateFilter,
  fromDate,
  toDate,
  dateSheetRef,
}: DateFilterSectionProps) => {
  const options = [
    { label: 'This Year', value: 'This Year' as const },
    { label: 'This Month', value: 'This Month' as const },
    {
      label:
        dateFilter === 'Custom'
          ? dayjs(fromDate).format('MMM DD, YYYY') + ' - ' + dayjs(toDate).format('MMM DD, YYYY')
          : 'Custom',
      value: 'Custom' as const,
      onPress: () => dateSheetRef.current?.present(),
    },
  ];

  return (
    <View paddingHorizontal={'$4'} paddingVertical={'$2'} mb={'$5'}>
      <View flexDirection={'row'} justifyContent={'space-between'} alignItems={'center'} mb={'$4'}>
        <Text fontSize={'$6'} fontWeight={'bold'}>
          Filter by Date
        </Text>
        {dateFilter !== null && (
          <LinkButton onPress={() => setDateFilter(null)}>
            <XCircle size={18} color={'white'} />
          </LinkButton>
        )}
      </View>
      <View flexDirection={'row'} gap={'$3'} flexWrap={'wrap'}>
        {options.map(option => (
          <DateFilterOption
            key={option.value}
            label={option.label}
            isSelected={dateFilter === option.value}
            onPress={option.onPress || (() => setDateFilter(option.value))}
          />
        ))}
      </View>
    </View>
  );
};

export default DateFilterSection;

================
File: components/filtering/FilterOptions.tsx
================
import React from 'react';
import { Text } from 'tamagui';
import { Check } from '@tamagui/lucide-icons';
import { LinkButton } from '../button/LinkButton';

type FilterOptionProps = {
  label: string;
  isSelected: boolean;
  onPress: () => void;
  icon?: string;
};

const FilterOption = ({ label, isSelected, onPress, icon }: FilterOptionProps) => (
  <LinkButton
    paddingHorizontal={'$4'}
    onPress={onPress}
    backgroundColor={isSelected ? '$green' : '$background075'}>
    <Text>
      {label} {icon}
    </Text>
    {isSelected && <Check size={12} color={'white'} />}
  </LinkButton>
);

export default FilterOption;

================
File: components/settings/SettingsItem.tsx
================
import * as React from 'react';
import { Text, View, YGroup } from 'tamagui';
import { ArrowRight } from '@tamagui/lucide-icons';
import { TouchableOpacity } from 'react-native';

type SettingsItemProps = {
  label: string;
  IconComponent?: React.ElementType;
  rightLabel?: string;
  onPress?: () => void;
};

export const SettingsItem = ({ label, IconComponent, rightLabel, onPress }: SettingsItemProps) => {
  const Component = onPress ? TouchableOpacity : View;
  return (
    <YGroup.Item>
      <View
        backgroundColor={'$gray1'}
        paddingVertical={'$2.5'}
        paddingHorizontal={'$4'}
        gap={'$4'}
        borderWidth={1}
        borderColor={'$borderColor'}>
        <Component onPress={onPress}>
          <View
            gap={'$4'}
            flexDirection={'row'}
            width={'100%'}
            justifyContent={'space-between'}
            alignItems={'center'}>
            <View flexDirection={'row'} alignItems={'center'} gap={'$2'}>
              {IconComponent && <IconComponent size={18} />}
              <Text fontSize={'$5'}>{label}</Text>
            </View>
            <View flexDirection={'row'} alignItems={'center'} gap={'$2'}>
              <Text fontSize={'$5'}>{rightLabel}</Text>
              <ArrowRight size={18} color={'$gray9'} />
            </View>
          </View>
        </Component>
      </View>
    </YGroup.Item>
  );
};

================
File: components/sheet/BottomSheetTextInput.tsx
================
import React, { memo, useCallback, forwardRef, useEffect } from 'react';
import type { NativeSyntheticEvent, TextInputFocusEventData } from 'react-native';
import { Input as TextInput } from 'tamagui';
import { useBottomSheetInternal } from '@gorhom/bottom-sheet';

const BottomSheetTextInputComponent = forwardRef<TextInput, React.ComponentProps<typeof TextInput>>(
  ({ onFocus, onBlur, ...rest }, ref) => {
    //#region hooks
    const { shouldHandleKeyboardEvents } = useBottomSheetInternal();
    //#endregion

    //#region callbacks
    const handleOnFocus = useCallback(
      (args: NativeSyntheticEvent<TextInputFocusEventData>) => {
        shouldHandleKeyboardEvents.value = true;
        if (onFocus) {
          onFocus(args);
        }
      },
      [onFocus, shouldHandleKeyboardEvents]
    );
    const handleOnBlur = useCallback(
      (args: NativeSyntheticEvent<TextInputFocusEventData>) => {
        shouldHandleKeyboardEvents.value = false;
        if (onBlur) {
          onBlur(args);
        }
      },
      [onBlur, shouldHandleKeyboardEvents]
    );
    //#endregion

    //#region effects
    useEffect(() => {
      return () => {
        // Reset the flag on unmount
        shouldHandleKeyboardEvents.value = false;
      };
    }, [shouldHandleKeyboardEvents]);
    //#endregion
    return <TextInput ref={ref} onFocus={handleOnFocus} onBlur={handleOnBlur} {...rest} />;
  }
);

export const BottomSheetTextInput = memo(BottomSheetTextInputComponent);
BottomSheetTextInput.displayName = 'BottomSheetTextInput';

================
File: components/sheet/constants.ts
================
export const snapPoints = ['90%'];
export const handleIndicatorStyle = { backgroundColor: 'white' };
export const backgroundStyle = {
  backgroundColor: '#1c1c23',
};

================
File: components/sheet/CreateCategorySheet.tsx
================
import React, { useState } from 'react';
import { useSafeAreaInsets } from 'react-native-safe-area-context';
import { BottomSheetModal, BottomSheetScrollView } from '@gorhom/bottom-sheet';
import { createCategory } from '../../database/helpers';
import { CustomBackdrop } from '../CustomBackdrop';
import { Input, Text, View } from 'tamagui';
import { spendingCategories } from '../../data/emojis';
import { Button } from '../button/Button';
import { PlusCircle } from '@tamagui/lucide-icons';
import { backgroundStyle, handleIndicatorStyle, snapPoints } from './constants';

type CreateCategorySheetProps = {
  sheetRef: React.RefObject<BottomSheetModal>;
};

export const CreateCategorySheet = ({ sheetRef }: CreateCategorySheetProps) => {
  const [name, setName] = useState('');
  const [selectedIcon, setSelectedIcon] = useState('');
  const { bottom } = useSafeAreaInsets();

  const handleCreate = () => {
    createCategory({ name, icon: selectedIcon }).then(() => {
      sheetRef.current?.close();
    });
  };
  return (
    <BottomSheetModal
      ref={sheetRef}
      enableContentPanningGesture={false}
      snapPoints={snapPoints}
      stackBehavior="push"
      enableDynamicSizing={false}
      enablePanDownToClose={true}
      animateOnMount={true}
      backdropComponent={CustomBackdrop}
      handleIndicatorStyle={handleIndicatorStyle}
      backgroundStyle={backgroundStyle}>
      <BottomSheetScrollView>
        <View padding={'$2'} gap={'$2'}>
          <Text ml={'$2'}>Enter Category Name</Text>
          <Input
            placeholder="Enter name"
            value={name}
            onChangeText={setName}
            gap={'$4'}
            width={'100%'}
          />
          <Text mt={'$2'} ml={'$2'}>
            Select Category Icon
          </Text>
          <View flexDirection={'row'} flexWrap={'wrap'} gap={'$4'} p={'$2'}>
            {spendingCategories.map((icon, index) => (
              <Button
                key={index}
                width={'auto'}
                onPress={() => setSelectedIcon(icon)}
                borderColor={icon === selectedIcon ? '$green' : undefined}>
                <Text>{icon}</Text>
              </Button>
            ))}
          </View>
        </View>
      </BottomSheetScrollView>
      <View padding={'$4'} gap={'$2'} mb={bottom}>
        <Button backgroundColor={'$green'} mt={'auto'} onPress={() => handleCreate()}>
          Create <PlusCircle size={18} color={'white'} />
        </Button>
      </View>
    </BottomSheetModal>
  );
};

================
File: components/sheet/ExportCSVSheet.tsx
================
import React, { useState } from 'react';
import { useSafeAreaInsets } from 'react-native-safe-area-context';
import { BottomSheetModal } from '@gorhom/bottom-sheet';
import { CustomBackdrop } from '../CustomBackdrop';
import { Separator, Spinner, Text, View, YStack } from 'tamagui';
import { Button } from '../button/Button';
import { FolderOutput } from '@tamagui/lucide-icons';
import { backgroundStyle, handleIndicatorStyle, snapPoints } from './constants';
import { DatePicker } from '../DatePicker';
import { CheckboxWithLabel } from '../checkbox/CheckBoxWithLabel';
import { useDatabase } from '@nozbe/watermelondb/hooks';
import { TransactionModel } from '../../database/transaction-model';
import { Q } from '@nozbe/watermelondb';
import Papa from 'papaparse';
import dayjs from 'dayjs';
import * as FileSystem from 'expo-file-system';
import * as Sharing from 'expo-sharing';

type ExportCSVSheetProps = {
  sheetRef: React.RefObject<BottomSheetModal>;
};

export const ExportCSVSheet = ({ sheetRef }: ExportCSVSheetProps) => {
  const { bottom } = useSafeAreaInsets();

  const [fromDate, setFromDate] = useState(new Date());
  const [toDate, setToDate] = useState(new Date());

  const [includedColumns, setIncludedColumns] = useState([
    { name: 'merchant', checked: true, label: 'Merchant/Vendor' },
    { name: 'amount', checked: true, label: 'Amount' },
    { name: 'date', checked: true, label: 'Date' },
    { name: 'note', checked: true, label: 'Note' },
    { name: 'currencyCode', checked: true, label: 'Currency' },
    { name: 'category', checked: false, label: 'Category' },
    { name: 'categoryIcon', checked: false, label: 'Category Icon' },
  ]);
  const [loading, setLoading] = useState(false);

  const database = useDatabase();
  const handleExport = async () => {
    setLoading(true);
    try {
      const transactions = await database.collections
        .get<TransactionModel>('transactions')
        .query(
          Q.unsafeSqlQuery(
            `
            SELECT transactions.*, categories.name as category, categories.icon as categoryIcon, 
                   strftime('%Y-%m-%d %H:%M:%SZ', transactions.date / 1000, 'unixepoch') as date
            FROM transactions
            LEFT JOIN categories ON transactions.categoryId = categories.id
            WHERE transactions.date >= ? AND transactions.date <= ? AND 
                transactions._status != 'deleted'
          `,
            [
              dayjs(fromDate).startOf('day').toDate().getTime(),
              dayjs(toDate).endOf('day').toDate().getTime(),
            ]
          )
        )
        .unsafeFetchRaw();

      const csv = Papa.unparse(
        transactions.map(transaction => {
          const tx: Partial<Record<keyof TransactionModel, unknown>> = {};
          includedColumns.forEach(column => {
            if (column.checked) {
              const key = column.name as keyof TransactionModel;
              tx[key] = transaction[key];
            }
          });
          return tx;
        })
      );
      const path = FileSystem.documentDirectory + `stoberi_export_${new Date().toISOString()}.csv`;
      await FileSystem.writeAsStringAsync(path, csv);
      await Sharing.shareAsync(path);
    } catch (error) {
      console.error(error);
    }
    setLoading(false);
  };
  return (
    <BottomSheetModal
      ref={sheetRef}
      enableContentPanningGesture={false}
      snapPoints={snapPoints}
      stackBehavior="push"
      enableDynamicSizing={false}
      enablePanDownToClose={true}
      animateOnMount={true}
      backdropComponent={CustomBackdrop}
      handleIndicatorStyle={handleIndicatorStyle}
      backgroundStyle={backgroundStyle}>
      <View padding={'$4'} gap={'$2'} pb={bottom + 16} height={'100%'}>
        <View flexDirection={'row'} justifyContent={'space-between'} alignItems={'center'}>
          <Text fontSize={'$6'} fontWeight={'bold'}>
            From Date
          </Text>
          <DatePicker date={fromDate} setDate={setFromDate} />
        </View>

        <View flexDirection={'row'} justifyContent={'space-between'} alignItems={'center'}>
          <Text fontSize={'$6'} fontWeight={'bold'}>
            To Date
          </Text>
          <DatePicker date={toDate} setDate={setToDate} />
        </View>
        <Separator marginVertical={15} />
        <Text>Include fields</Text>
        <YStack>
          {includedColumns.map((column, index) => (
            <CheckboxWithLabel
              key={index}
              size="$4"
              defaultChecked={column.checked}
              label={column.label}
              name={column.name}
              checked={column.checked}
              onCheckedChange={checked => {
                setIncludedColumns(
                  includedColumns.map(c =>
                    c.name === column.name ? { ...c, checked: !!checked } : c
                  )
                );
              }}
            />
          ))}
        </YStack>
        <Button
          fontWeight={'bold'}
          backgroundColor={'$green'}
          mt={'auto'}
          onPress={() => handleExport()}
          disabled={loading}>
          Export{' '}
          {loading ? <Spinner color={'white'} /> : <FolderOutput size={18} color={'white'} />}
        </Button>
      </View>
    </BottomSheetModal>
  );
};

================
File: components/sheet/ImportCSVSheet.tsx
================
import React, { useState } from 'react';
import { useSafeAreaInsets } from 'react-native-safe-area-context';
import { BottomSheetModal } from '@gorhom/bottom-sheet';
import { CustomBackdrop } from '../CustomBackdrop';
import { Spinner, Text, View, YStack } from 'tamagui';
import { Button } from '../button/Button';
import { FolderInput } from '@tamagui/lucide-icons';
import { backgroundStyle, handleIndicatorStyle } from './constants';
import * as DocumentPicker from 'expo-document-picker';
import * as FileSystem from 'expo-file-system';
import * as Sharing from 'expo-sharing';
import Papa from 'papaparse';
import {
  createCategory,
  createTransaction,
  CreateTransactionPayload,
} from '../../database/helpers';
import { currencies } from '../../data/currencies';
import { useDatabase } from '@nozbe/watermelondb/hooks';
import { CategoryModel } from '../../database/category-model';
import useToast from '../../hooks/useToast';
import { useDefaultCurrency } from '../../hooks/useDefaultCurrency';

interface CSVRow {
  merchant: string;
  amount: string;
  date: string;
  note?: string;
  currencyCode: string;
  category?: string;
  categoryIcon?: string;
}

type ImportCSVSheetProps = {
  sheetRef: React.RefObject<BottomSheetModal>;
};

const snapPoints = ['50%'];
export const ImportCSVSheet = ({ sheetRef }: ImportCSVSheetProps) => {
  const toast = useToast();
  const { bottom } = useSafeAreaInsets();
  const [importing, setImporting] = useState(false);
  const [downloading, setDownloading] = useState(false);

  const { defaultCurrency } = useDefaultCurrency();
  const database = useDatabase();
  const handleImport = async () => {
    setImporting(true);
    try {
      const res = await DocumentPicker.getDocumentAsync({ type: 'text/csv' });
      if (res.assets?.[0].uri) {
        const content = await FileSystem.readAsStringAsync(res.assets?.[0].uri);
        Papa.parse<CSVRow>(content, {
          header: true,
          complete: async results => {
            const categories = await database.get<CategoryModel>('categories').query().fetch();
            if (results.data.length === 0) {
              console.log('No data found in the CSV file');
              setImporting(false);
              return;
            }

            const requiredColumns = ['merchant', 'amount', 'date', 'currencyCode'];
            const missingColumns = requiredColumns.filter(
              col => !results.meta.fields?.includes(col)
            );

            if (missingColumns.length > 0) {
              console.log(`Missing required columns: ${missingColumns.join(', ')}`);
              setImporting(false);
              toast.alert({
                title: 'Failed to import.',
                preset: 'error',
                message: `Missing required columns: ${missingColumns.join(', ')}`,
              });
              return;
            }

            const validTransactions: CreateTransactionPayload[] = [];
            const errors: string[] = [];

            for (let index = 0; index < results.data.length; index++) {
              const row = results.data[index];
              if (
                row &&
                typeof row === 'object' &&
                (!('merchant' in row) ||
                  !('amount' in row) ||
                  !('date' in row) ||
                  !('currencyCode' in row))
              ) {
                errors.push(`Row ${index + 1}: Missing required fields`);
              }
              const { merchant, amount, date, note, currencyCode, category, categoryIcon } = row;

              if (!amount || !date || !currencyCode) {
                errors.push(`Row ${index + 1}: Missing required fields`);
              }

              if (isNaN(Number(amount))) {
                errors.push(`Row ${index + 1}: Amount should be a number`);
              }

              const parsedDate = new Date(date);
              if (isNaN(parsedDate.getTime())) {
                errors.push(`Row ${index + 1}: Invalid date format`);
              }
              // valid currency code
              if (!currencies.some(currency => currency.code === currencyCode)) {
                errors.push(`Row ${index + 1}: Invalid currency code`);
              }

              let matchedCategory = categories.find(cat => cat.name === category);

              if (!matchedCategory && category && categoryIcon && !errors.length) {
                matchedCategory = await createCategory({
                  name: category,
                  icon: categoryIcon,
                });
              }
              validTransactions.push({
                merchant,
                amount: Number(amount),
                date: parsedDate,
                note: note || '',
                currencyCode,
                categoryId: matchedCategory?.id ?? null,
                baseCurrency: defaultCurrency as string,
              });
            }

            if (errors.length > 0) {
              toast.alert({
                title: 'Failed to import.',
                preset: 'error',
                message: errors.join('\n'),
              });
              setImporting(false);
              return;
            }

            for (const transaction of validTransactions) {
              await createTransaction(transaction);
            }

            if (validTransactions.length > 0) {
              toast.show({
                title: 'Success',
                message: `Imported ${validTransactions.length} ${
                  validTransactions.length === 1 ? 'transaction' : 'transactions'
                }`,
                preset: 'custom',
                duration: 2,
              });
            } else {
              toast.show({
                title: 'Error',
                message: `No transactions found in the CSV file`,
                preset: 'error',
                duration: 2,
              });
            }

            // showToast(validTransactions.length);
            sheetRef.current?.dismiss();
          },
        });
      }
    } catch (e) {
      console.error(e);
    }
    setImporting(false);
  };

  const handleDownloadCSVFileTemplate = async () => {
    setDownloading(true);
    try {
      const template = `merchant,amount,date,note,currencyCode,category,categoryIcon`;
      const uri = FileSystem.cacheDirectory + 'template.csv';
      await FileSystem.writeAsStringAsync(uri, template);
      await Sharing.shareAsync(uri);
    } catch (e) {
      console.error(e);
    }
    setDownloading(false);
  };
  return (
    <BottomSheetModal
      ref={sheetRef}
      enableContentPanningGesture={false}
      snapPoints={snapPoints}
      stackBehavior="push"
      enableDynamicSizing={false}
      enablePanDownToClose={true}
      animateOnMount={true}
      backdropComponent={CustomBackdrop}
      handleIndicatorStyle={handleIndicatorStyle}
      backgroundStyle={backgroundStyle}>
      <View padding={'$4'} gap={'$2'} pb={bottom + 16} height={'100%'}>
        <View flexDirection={'row'} justifyContent={'space-between'} alignItems={'center'}>
          <Text fontSize={'$6'} fontWeight={'bold'}>
            Import Transactions from CSV file
          </Text>
        </View>
        <Text>
          Make sure your CSV file is in the correct format. You can download an example CSV file
          bellow.
        </Text>
        <YStack gap={'$4'} mt={'auto'}>
          <Button
            fontWeight={'bold'}
            backgroundColor={'#0f396e'}
            onPress={() => handleDownloadCSVFileTemplate()}
            disabled={importing}>
            Download CSV file template
            {downloading ? <Spinner color={'white'} /> : null}
          </Button>
          <Button
            fontWeight={'bold'}
            backgroundColor={'$green'}
            mt={'auto'}
            onPress={() => handleImport()}
            disabled={importing}>
            Import
            {importing ? <Spinner color={'white'} /> : <FolderInput size={18} color={'white'} />}
          </Button>
        </YStack>
      </View>
    </BottomSheetModal>
  );
};

================
File: components/sheet/ManageCategoriesSheet.tsx
================
import React, { useRef, useState } from 'react';
import { useDatabase } from '@nozbe/watermelondb/hooks';
import { BottomSheetView, BottomSheetModal } from '@gorhom/bottom-sheet';
import { backgroundStyle, handleIndicatorStyle, snapPoints } from './constants';
import { Text, View } from 'tamagui';
import { LinkButton } from '../button/LinkButton';
import { PlusCircle } from '@tamagui/lucide-icons';
import { CategoriesList } from '../CategoriesList';
import { CreateCategorySheet } from './CreateCategorySheet';
import { CategoryModel } from '../../database/category-model';
import { CustomBackdrop } from '../CustomBackdrop';
import { BottomSheetTextInput } from './BottomSheetTextInput';

type ManageCategoriesSheetProps = {
  selectedCategory?: CategoryModel | null;
  selectedCategories?: CategoryModel[];
  setSelectedCategory?: (category: CategoryModel) => void;
  interactive?: boolean;
  sheetRef: React.RefObject<BottomSheetModal>;
  preventClose?: boolean;
  noSearch?: boolean;
};

export const ManageCategoriesSheet = ({
  selectedCategory,
  setSelectedCategory,
  sheetRef,
  preventClose = false,
  selectedCategories,
  noSearch,
}: ManageCategoriesSheetProps) => {
  const [search, setSearch] = useState('');
  const ref = useRef<BottomSheetModal | null>(null);
  const database = useDatabase();
  return (
    <>
      <BottomSheetModal
        ref={sheetRef}
        $modal={false}
        stackBehavior={'push'}
        enableContentPanningGesture={false}
        snapPoints={snapPoints}
        enableDynamicSizing={false}
        enablePanDownToClose={true}
        animateOnMount={true}
        handleIndicatorStyle={handleIndicatorStyle}
        backdropComponent={CustomBackdrop}
        backgroundStyle={backgroundStyle}>
        <BottomSheetView>
          <View
            flexDirection={'row'}
            alignItems={'center'}
            paddingHorizontal={'$3'}
            width={'100%'}
            justifyContent={'space-between'}
            marginBottom={'$2'}>
            <Text color={'white'} fontSize={'$6'}>
              Categories
            </Text>
            <LinkButton
              alignSelf={'center'}
              color={'white'}
              backgroundColor={'$green'}
              onPress={() => ref.current?.present()}>
              <PlusCircle size={18} color={'white'} />
            </LinkButton>
          </View>
          {!noSearch && (
            <View padding={'$2'}>
              <BottomSheetTextInput
                placeholder="Search categories"
                value={search}
                onChangeText={setSearch}
                gap={'$4'}
                width={'100%'}
              />
            </View>
          )}
          <CategoriesList
            preventClose={preventClose}
            search={search}
            database={database}
            onSelect={setSelectedCategory}
            selectedCategory={selectedCategory}
            selectedCategories={selectedCategories}
          />
        </BottomSheetView>
      </BottomSheetModal>
      <CreateCategorySheet sheetRef={ref} />
    </>
  );
};

================
File: components/CategoriesList.tsx
================
import { CategoryModel } from '../database/category-model';
import { useSafeAreaInsets } from 'react-native-safe-area-context';
import React, { useCallback, useMemo } from 'react';
import { BottomSheetFlatList, TouchableOpacity, useBottomSheet } from '@gorhom/bottom-sheet';
import { CurrencyItem } from './CurrencyItem';
import { withObservables } from '@nozbe/watermelondb/react';
import { Database, Q } from '@nozbe/watermelondb';
import { Observable } from 'rxjs';

type CategoriesListProps = {
  categories: CategoryModel[];
  onSelect?: (category: CategoryModel) => void;
  selectedCategory?: CategoryModel;
  preventClose?: boolean;
  selectedCategories?: CategoryModel[];
};

const Component = ({
  categories,
  onSelect,
  selectedCategory,
  preventClose,
  selectedCategories,
}: CategoriesListProps) => {
  const { bottom } = useSafeAreaInsets();
  const { close } = useBottomSheet();
  const renderItem = useCallback(
    ({ item: category }: { item: CategoryModel }) => (
      <TouchableOpacity
        key={category.id}
        onPress={() => {
          if (onSelect) {
            onSelect(category);
            if (!preventClose) {
              close();
            }
          }
        }}
        disabled={!onSelect}>
        <CurrencyItem
          name={category.name}
          code={category.icon}
          selected={
            category.id === selectedCategory?.id ||
            selectedCategories?.some(c => c.id === category.id)
          }
        />
      </TouchableOpacity>
    ),
    [selectedCategory, selectedCategories]
  );

  const props = useMemo(
    () => ({
      contentInset: {
        bottom: bottom + 16,
      },
      contentContainerStyle: {
        paddingBottom: bottom,
      },
      style: { marginBottom: bottom },
    }),
    [bottom]
  );

  return (
    <BottomSheetFlatList
      data={categories}
      keyExtractor={keyExtractor}
      renderItem={renderItem}
      bounces={false}
      keyboardShouldPersistTaps={'always'}
      {...props}
    />
  );
};

const enhance = withObservables<
  { database: Database; search: string },
  { categories: Observable<CategoryModel[]> }
>(['search'], ({ database, search }) => {
  return {
    categories: database.collections
      .get<CategoryModel>('categories')
      .query(Q.where('name', Q.like('%' + search + '%')), Q.sortBy('created_at', 'desc'))
      .observe(),
  };
});

export const CategoriesList = enhance(Component);

const keyExtractor = (item: CategoryModel) => item.id;

================
File: components/CreateExpenseItem.tsx
================
import { Separator, Text, View, YGroup } from 'tamagui';
import React from 'react';

type CreateExpenseItemProps = {
  IconComponent: React.ElementType;
  label: string;
  children: React.ReactNode;
  bottom?: React.ReactNode;
};
export const CreateExpenseItem = ({
  IconComponent,
  label,
  children,
  bottom,
}: CreateExpenseItemProps) => {
  return (
    <YGroup.Item>
      <View backgroundColor={'$gray1'} paddingVertical={'$2.5'} paddingHorizontal={'$4'} gap={'$4'}>
        <View
          gap={'$4'}
          flexDirection={'row'}
          width={'100%'}
          justifyContent={'space-between'}
          alignItems={'center'}>
          <View flexDirection={'row'} alignItems={'center'} gap={'$2'}>
            <IconComponent size={20} />
            <Text fontSize={'$5'}>{label}</Text>
          </View>
          {children}
        </View>
        {bottom && (
          <>
            <Separator />
            {bottom}
          </>
        )}
      </View>
    </YGroup.Item>
  );
};

================
File: components/CreateFirstTransactionButton.tsx
================
import { View, YStack } from 'tamagui';
import { Button } from './button/Button';
import { CarouselItemText } from './carousel/CarouselItemText';
import { PlusCircle } from '@tamagui/lucide-icons';
import * as React from 'react';
import { useRouter } from 'expo-router';

type CreateFirstTransactionButton = React.ComponentProps<typeof YStack>;
export const CreateFirstTransactionButton = ({ ...rest }: CreateFirstTransactionButton) => {
  const router = useRouter();
  return (
    <YStack alignItems={'center'} justifyContent={'center'} {...rest}>
      <Button
        height={'auto'}
        onPress={() => {
          router.push({
            pathname: '/create-transaction',
            params: {
              transactionType: 'expense',
            },
          });
        }}>
        <View alignItems={'center'} py={'$3'} gap={'$2'}>
          <CarouselItemText color={'white'}>Create your first transaction</CarouselItemText>
          <PlusCircle size={32} color={'white'} />
        </View>
      </Button>
    </YStack>
  );
};

================
File: components/CurrencyInput.tsx
================
import { SizeTokens, Text } from 'tamagui';
import { View, Input } from 'tamagui';
import { ChevronRight } from '@tamagui/lucide-icons';

type CurrencyInputProps = {
  size?: SizeTokens;
  focusOnMount?: boolean;
  labelText?: string;
  onChangeText?: (text: string) => void;
  onCurrencySelect: () => void;
  selectedCurrency: string;
  value: string;
};
export function CurrencyInput({
  focusOnMount = false,
  onChangeText,
  onCurrencySelect,
  selectedCurrency,
  value,
}: CurrencyInputProps) {
  return (
    <View flexDirection="column" justifyContent="center" alignItems="center">
      <View
        width={'100%'}
        flexDirection={'row'}
        borderWidth={1}
        borderColor={'$borderColor'}
        backgroundColor={'$gray5'}
        borderRadius={'$4'}>
        <Input
          borderRadius={'$0'}
          backgroundColor={'transparent'}
          borderWidth={0}
          keyboardType={'numeric'}
          style={{
            height: 64,
            fontSize: 32,
            flex: 1,
          }}
          id="currencyInput"
          placeholder="00.00"
          autoFocus={focusOnMount}
          onChangeText={onChangeText}
          value={value}
        />
        <View
          onTouchStart={() => onCurrencySelect()}
          borderColor={'$borderColor'}
          borderLeftWidth={2}
          paddingHorizontal={'$2'}
          backgroundColor={'transparent'}
          flexDirection={'row'}
          alignItems={'center'}>
          <Text color={'gray'} fontSize={'$8'}>
            {selectedCurrency}
          </Text>
          <ChevronRight size={24} color={'gray'} />
        </View>
      </View>
    </View>
  );
}

================
File: components/CurrencyItem.tsx
================
import { Text, View } from 'tamagui';
import * as React from 'react';
import { Check } from '@tamagui/lucide-icons';

type CurrencyItemProps = {
  name: string;
  code: string;
  selected?: boolean;
};

export const CurrencyItem = ({ name, code, selected }: CurrencyItemProps) => {
  return (
    <View
      backgroundColor={'transparent'}
      flexDirection={'row'}
      paddingVertical={'$3'}
      paddingHorizontal={'$4'}
      gap={'$4'}
      borderWidth={'$0.5'}
      borderColor={'$borderColor'}
      borderRadius={'$0'}>
      <View flexDirection={'column'}>
        <Text fontSize={'$5'} fontWeight={'bold'}>
          {name}
        </Text>
      </View>
      <View marginLeft={'auto'} alignItems={'flex-end'} flexDirection={'row'} gap={'$3'}>
        {selected && <Check size={20} />}
        <Text fontSize={'$5'}>{code}</Text>
      </View>
    </View>
  );
};

================
File: components/CurrencySelect.tsx
================
import React, { useCallback, useMemo, useState } from 'react';
import {
  BottomSheetFlatList,
  BottomSheetModal,
  BottomSheetView,
  TouchableOpacity,
} from '@gorhom/bottom-sheet';
import { currencies, Currency } from '../data/currencies';
import { CurrencyItem } from './CurrencyItem';
import { useSafeAreaInsets } from 'react-native-safe-area-context';
import { backgroundStyle, handleIndicatorStyle, snapPoints } from './sheet/constants';
import { Input, View } from 'tamagui';

type CurrencySelectProps = {
  selectedCurrency: string;
  onSelect: (currency: Currency) => void;
  sheetRef: React.RefObject<BottomSheetModal>;
};
export const CurrencySelect = ({ selectedCurrency, onSelect, sheetRef }: CurrencySelectProps) => {
  const renderItem = useCallback(
    ({ item: currency }: { item: Currency }) => (
      <React.Fragment key={currency.code}>
        <TouchableOpacity
          onPress={() => {
            onSelect(currency);
          }}>
          <CurrencyItem
            name={currency.name}
            code={currency.code}
            selected={currency.code === selectedCurrency}
          />
        </TouchableOpacity>
      </React.Fragment>
    ),
    [selectedCurrency]
  );

  const [search, setSearch] = useState('');
  const filteredData = useMemo(
    () =>
      currencies
        .filter(
          currency =>
            currency.name.toLowerCase().includes(search.toLowerCase()) ||
            currency.code.toLowerCase().includes(search.toLowerCase())
        )
        .sort((a, b) => {
          if (a.code === selectedCurrency) {
            return -1;
          }
          if (b.code === selectedCurrency) {
            return 1;
          }
          return 0;
        }),
    [search, selectedCurrency]
  );
  const { bottom } = useSafeAreaInsets();
  return (
    <BottomSheetModal
      enableContentPanningGesture={false}
      ref={sheetRef}
      snapPoints={snapPoints}
      enablePanDownToClose={true}
      enableDynamicSizing={false}
      animateOnMount={true}
      handleIndicatorStyle={handleIndicatorStyle}
      backgroundStyle={backgroundStyle}>
      <BottomSheetView>
        <View padding={'$2'}>
          <Input placeholder="Search currencies" value={search} onChangeText={setSearch} />
        </View>
        <BottomSheetFlatList
          data={filteredData}
          keyExtractor={i => i.code}
          renderItem={renderItem}
          contentInset={{
            bottom,
          }}
          style={{
            marginBottom: bottom,
          }}
        />
      </BottomSheetView>
    </BottomSheetModal>
  );
};

================
File: components/CustomBackdrop.tsx
================
import React, { useMemo } from 'react';
import { BottomSheetBackdropProps, useBottomSheetModal } from '@gorhom/bottom-sheet';
import Animated, {
  Extrapolation,
  interpolate,
  useAnimatedProps,
  useAnimatedStyle,
} from 'react-native-reanimated';
import { BlurView } from 'expo-blur';

const AnimatedBlurView = Animated.createAnimatedComponent(BlurView);

export const CustomBackdrop = ({ animatedIndex, style }: BottomSheetBackdropProps) => {
  const containerAnimatedStyle = useAnimatedStyle(() => ({
    backgroundColor: `rgba(0,0,0,${interpolate(
      animatedIndex.value,
      [-1, 0],
      [0, 0.5],
      Extrapolation.CLAMP
    )})`,
  }));

  const { dismiss } = useBottomSheetModal();
  const containerStyle = useMemo(() => [style, containerAnimatedStyle], [style]);

  const blurViewProps = useAnimatedProps(() => {
    return {
      intensity: interpolate(animatedIndex.value, [-1, 0], [0, 10], Extrapolation.CLAMP),
    };
  });

  return (
    <AnimatedBlurView
      animatedProps={blurViewProps}
      style={containerStyle}
      onTouchEnd={() => {
        dismiss();
      }}
    />
  );
};

================
File: components/DatePicker.tsx
================
import React from 'react';
import DateTimePicker, { DateTimePickerEvent } from '@react-native-community/datetimepicker';
import { Platform } from 'react-native';
import { Text, View } from 'tamagui';
type DatePickerProps = {
  mode?: 'date' | 'time';
  date: Date;
  setDate: (date: Date) => void;
};

export const DatePicker = ({ mode = 'date', date, setDate }: DatePickerProps) => {
  const [show, setShow] = React.useState(false);
  const onChange = (event: DateTimePickerEvent, selectedDate?: Date) => {
    setDate(selectedDate || date);
    setShow(false);
  };

  const picker = (
    <DateTimePicker
      themeVariant="dark"
      testID="dateTimePicker"
      value={date}
      mode={mode}
      is24Hour={true}
      onChange={onChange}
    />
  );
  if (Platform.OS === 'ios') {
    return picker;
  } else {
    return (
      <>
        {show && picker}
        <View
          borderColor={'$borderColor'}
          borderWidth={0.5}
          borderRadius={8}
          padding={'$2'}
          onPress={() => setShow(true)}>
          <Text color={'white'}>
            {mode === 'date' ? date.toLocaleDateString() : date.toLocaleTimeString()}
          </Text>
        </View>
      </>
    );
  }
};

================
File: components/DocumentPicker.tsx
================
import { Text, View } from 'tamagui';
import { PlusCircle } from '@tamagui/lucide-icons';
import React from 'react';
import * as DocumentPickerLib from 'expo-document-picker';

export const DocumentPicker = () => {
  return (
    <View
      onTouchStart={() => DocumentPickerLib.getDocumentAsync()}
      mt={'$4'}
      alignItems={'center'}
      justifyContent={'center'}
      gap={'$4'}
      flexDirection={'row'}
      borderWidth={1}
      borderColor={'$borderColor'}
      borderRadius={'$4'}
      backgroundColor={'$gray1'}
      padding={'$4'}>
      <PlusCircle />
      <Text>Add Attachments</Text>
    </View>
  );
};

================
File: components/HomeTransactionsSection.tsx
================
import { TransactionModel } from '../database/transaction-model';
import { withObservables } from '@nozbe/watermelondb/react';
import { Database, Q } from '@nozbe/watermelondb';
import { Observable } from 'rxjs';
import { YGroup } from 'tamagui';
import { TransactionItem } from './TransactionItem';
import dayjs from 'dayjs';
import { DateFormats } from '../lib/date';
import * as React from 'react';
import Reanimated, { LinearTransition } from 'react-native-reanimated';
import { useSafeAreaInsets } from 'react-native-safe-area-context';

type RecentTransactionsSectionProps = {
  transactions: TransactionModel[];
  header: React.ReactNode;
};
export const HomeTransactionsSection = withObservables<
  { database: Database },
  { transactions: Observable<TransactionModel[]> }
>([], ({ database }) => {
  return {
    transactions: database.collections
      .get<TransactionModel>('transactions')
      .query(Q.sortBy('date', 'desc'), Q.take(20))
      .observe(),
  };
})(({ transactions, header }: RecentTransactionsSectionProps) => {
  const { bottom } = useSafeAreaInsets();
  if (transactions.length === 0) {
    return null;
  }
  return (
    <>
      <YGroup>
        <Reanimated.FlatList
          contentInset={{
            bottom: 64 + bottom,
          }}
          ListHeaderComponent={() => header}
          itemLayoutAnimation={LinearTransition}
          data={transactions}
          keyExtractor={transaction => transaction.id}
          renderItem={({ item: transaction }) => (
            <TransactionItem
              date={dayjs(transaction.date).format(DateFormats.FullMonthFullDayTime)}
              transaction={transaction}
            />
          )}
        />
      </YGroup>
    </>
  );
});

================
File: components/InfoItem.tsx
================
import { Text, View, YGroup } from 'tamagui';
import * as React from 'react';

export const InfoItem = ({
  title,
  value,
  color,
}: {
  title: string;
  value: string;
  color?: string;
}) => {
  return (
    <YGroup.Item>
      <View gap={'$1'}>
        <Text fontSize={'$2'}>{title}</Text>
        <Text fontSize={'$5'} fontWeight={'bold'} color={color}>
          {value}
        </Text>
      </View>
    </YGroup.Item>
  );
};

================
File: components/SpendOverview.tsx
================
import dayjs from 'dayjs';
import { CarouselItemWrapper } from './carousel/CarouselItemWrapper';
import { Text, View, YGroup } from 'tamagui';
import { Calendar } from '@tamagui/lucide-icons';

import { LinkButton } from './button/LinkButton';
import * as React from 'react';
import { withObservables } from '@nozbe/watermelondb/react';
import { Database, Q } from '@nozbe/watermelondb';
import { map, Observable } from 'rxjs';
import { TransactionModel } from '../database/transaction-model';
import { formatCurrency } from '../lib/format';
import { useDefaultCurrency } from '../hooks/useDefaultCurrency';
import { CategoryModel } from '../database/category-model';
import { InfoItem } from './InfoItem';
import { formatDateRange } from '../lib/date';

type SpendOverviewProps = {
  totalExpense: number;
  totalIncome: number;
  transactionCount: number;
  highestSpendCategory$: { category: string; total: number };
  categories: CategoryModel[];
  onDatePress: () => void;
  fromDate: dayjs.Dayjs;
  toDate: dayjs.Dayjs;
};
export const SpendOverview = withObservables<
  {
    database: Database;
    fromDate: dayjs.Dayjs;
    toDate: dayjs.Dayjs;
  },
  {
    totalExpense: Observable<number>;
    totalIncome: Observable<number>;
    transactionCount: Observable<number>;
    highestSpendCategory$: Observable<{ category: string; total: number }>;
    categories: Observable<CategoryModel[]>;
  }
>(['fromDate', 'toDate'], ({ database, fromDate: fd, toDate: td }) => {
  const fromDate = fd.toDate().getTime();
  const toDate = td.toDate().getTime();
  const highestSpendCategory$ = database.collections
    .get<TransactionModel>('transactions')
    .query(
      Q.where('amountInBaseCurrency', Q.lt(0)),
      Q.where('date', Q.gte(fromDate)),
      Q.where('date', Q.lte(toDate))
    )
    .observe()
    .pipe(
      map(transactions => {
        const categories = transactions.reduce(
          (acc, transaction) => {
            const category = transaction.category?.id || 'Uncategorized';
            if (!acc[category]) {
              acc[category] = 0;
            }
            acc[category] += Math.abs(transaction.amountInBaseCurrency);
            return acc;
          },
          {} as Record<string, number>
        );

        return Object.entries(categories).reduce(
          (max, [category, total]) => (total > max.total ? { category, total } : max),
          { category: 'Uncategorized', total: 0 }
        );
      })
    );

  return {
    totalExpense: database.collections
      .get<TransactionModel>('transactions')
      .query(
        Q.where('amountInBaseCurrency', Q.lt(0)),
        Q.where('date', Q.gte(fromDate)),
        Q.where('date', Q.lte(toDate))
      )
      .observe()
      .pipe(
        map(transactions =>
          transactions.reduce((sum, transaction) => sum + transaction.amountInBaseCurrency, 0)
        )
      ),
    totalIncome: database.collections
      .get<TransactionModel>('transactions')
      .query(
        Q.where('amountInBaseCurrency', Q.gte(0)),
        Q.where('date', Q.gte(fromDate)),
        Q.where('date', Q.lte(toDate))
      )
      .observe()
      .pipe(
        map(transactions =>
          transactions.reduce((sum, transaction) => sum + transaction.amountInBaseCurrency, 0)
        )
      ),
    transactionCount: database.collections
      .get<TransactionModel>('transactions')
      .query(Q.where('date', Q.gte(fromDate)), Q.where('date', Q.lte(toDate)))
      .observeCount(),
    highestSpendCategory$,
    categories: database.collections.get<CategoryModel>('categories').query().observe(),
  };
})(({
  totalExpense,
  fromDate,
  toDate,
  totalIncome,
  transactionCount,
  highestSpendCategory$,
  categories,
  onDatePress,
}: SpendOverviewProps) => {
  const { defaultCurrency } = useDefaultCurrency();

  const category = categories.find(c => c.id === highestSpendCategory$.category);
  return (
    <CarouselItemWrapper>
      <View
        justifyContent={'flex-start'}
        flexDirection={'row'}
        marginBottom={'$4'}
        paddingHorizontal={'$3'}>
        <LinkButton onPress={onDatePress} color={'white'} backgroundColor={'$gray2'}>
          <View flexDirection={'row'} gap={'$2'} alignItems={'center'}>
            <Text fontSize={'$5'}>{formatDateRange(fromDate, toDate)}</Text>
            <Calendar size={16} />
          </View>
        </LinkButton>
      </View>
      <YGroup
        flexDirection={'row'}
        paddingHorizontal={'$4'}
        justifyContent={'space-between'}
        mb={'$5'}>
        <YGroup gap={'$5'}>
          <InfoItem
            title={'Period Income'}
            color={'$green'}
            value={defaultCurrency ? formatCurrency(totalIncome, defaultCurrency) : ''}
          />
          <InfoItem
            title={'Period Balance'}
            color={totalIncome + totalExpense >= 0 ? '$green' : '$stroberi'}
            value={
              defaultCurrency ? formatCurrency(totalIncome + totalExpense, defaultCurrency) : ''
            }
          />
        </YGroup>
        <YGroup paddingHorizontal={'$4'} gap={'$5'}>
          <InfoItem
            title={'Period Spend'}
            color={'$stroberi'}
            value={defaultCurrency ? formatCurrency(totalExpense, defaultCurrency) : ''}
          />
          <InfoItem title={'Transaction No.'} value={transactionCount.toString()} />
        </YGroup>
      </YGroup>
      {!!category && (
        <View paddingHorizontal={'$4'} gap={'$1'} mb={'$2'}>
          <Text fontSize={'$2'}>Top Spend Category</Text>
          <Text fontSize={'$5'} fontWeight={'bold'}>
            {category?.name ?? 'Uncategorized'} {category?.icon}{' '}
            {defaultCurrency ? formatCurrency(highestSpendCategory$?.total, defaultCurrency) : null}
          </Text>
        </View>
      )}
    </CarouselItemWrapper>
  );
});

================
File: components/StyledScrollView.tsx
================
import { styled } from 'tamagui';
import { KeyboardAwareScrollView } from 'react-native-keyboard-controller';

export const StyledScrollView = styled(KeyboardAwareScrollView, {
  backgroundColor: '$bgPrimary',
  paddingHorizontal: '$2',
  paddingTop: '$4',
});

================
File: components/Switch.tsx
================
import { Stack, styled } from '@tamagui/core';

import { createSwitch } from '@tamagui/switch';

const Frame = styled(Stack, {
  width: 60,
  height: 30,
  borderRadius: 20,
  variants: {
    checked: {
      true: {
        backgroundColor: '$green',
      },
      false: {
        backgroundColor: '$gray4',
      },
    },
  } as const,

  defaultVariants: {
    checked: false,
  },
});

const Thumb = styled(Stack, {
  width: 30,
  height: 30,
  backgroundColor: 'white',
  borderRadius: 20,
  variants: {
    checked: {
      true: {
        opacity: 0.8,
      },
      false: {
        opacity: 0.5,
      },
    },
  } as const,
});
export const Switch = createSwitch({
  Frame,
  Thumb,
});

================
File: components/TransactionItem.tsx
================
import { Text, View, YGroup } from 'tamagui';
import * as React from 'react';
import { Pen, Trash2 } from '@tamagui/lucide-icons';
import { CategoryModel } from '../database/category-model';
import { TransactionModel } from '../database/transaction-model';
import { withObservables } from '@nozbe/watermelondb/react';
import { formatCurrency } from '../lib/format';
import * as ContextMenu from 'zeego/context-menu';
import { useRouter } from 'expo-router';
import ReanimatedSwipeable from 'react-native-gesture-handler/ReanimatedSwipeable';
import { useActionSheet } from '@expo/react-native-action-sheet';
import Animated, { SharedValue, useAnimatedStyle } from 'react-native-reanimated';
import { Pressable } from 'react-native';
import { Observable } from 'rxjs';

type TransactionItemProps = {
  category?: CategoryModel | null;
  transaction: TransactionModel;
  date: string;
};

export const TransactionItem = withObservables<
  { transaction: TransactionModel },
  { transaction: Observable<TransactionModel>; category?: Observable<CategoryModel | null> }
>(['transaction'], ({ transaction }) => {
  return {
    category: transaction.category?.observe(),
    transaction: transaction.observe(),
  };
})(({ date, category, transaction }: TransactionItemProps) => {
  const { showActionSheetWithOptions } = useActionSheet();

  const router = useRouter();

  const onEdit = () => {
    router.push({
      pathname: '/create-transaction',
      params: {
        transaction: JSON.stringify(transaction._raw),
        category: JSON.stringify(category?._raw),
      },
    });
  };

  const onDelete = () => {
    showActionSheetWithOptions(
      {
        title: 'Are you sure you want to delete this transaction?',
        options: ['Delete', 'Cancel'],
        destructiveButtonIndex: 0,
        cancelButtonIndex: 1,
      },
      async buttonIndex => {
        if (buttonIndex === 0) {
          await transaction.deleteTx();
        }
      }
    );
  };
  const renderRightAction = (prog: SharedValue<number>, drag: SharedValue<number>) => {
    const styleAnimation = useAnimatedStyle(() => {
      return {
        transform: [{ translateX: drag.value + 100 }],
        flexDirection: 'row',
      };
    });

    return (
      <Animated.View style={styleAnimation}>
        <View backgroundColor={'gray'} width={50}>
          <Pressable
            style={{ flex: 1, alignItems: 'center', justifyContent: 'center', width: '100%' }}
            onPress={onEdit}
            accessibilityLabel="Edit transaction"
            accessibilityRole="button">
            <Pen height={24} width={24} />
          </Pressable>
        </View>
        <View backgroundColor={'$stroberiLight'} width={50}>
          <Pressable
            style={{
              flex: 1,
              alignItems: 'center',
              justifyContent: 'center',
              width: '100%',
            }}
            onPress={onDelete}>
            <Trash2 height={8} width={8} />
          </Pressable>
        </View>
      </Animated.View>
    );
  };

  const component = (
    <YGroup.Item key={transaction.id}>
      <ReanimatedSwipeable
        friction={2}
        enableTrackpadTwoFingerGesture
        rightThreshold={40}
        renderRightActions={renderRightAction}>
        <View
          flexDirection={'row'}
          paddingVertical={'$2'}
          paddingHorizontal={'$4'}
          gap={'$4'}
          borderWidth={1}
          borderColor={'$borderColor'}>
          <Text fontSize={'$5'}>{category?.icon ?? '📦'}</Text>
          <View flexDirection={'column'} justifyContent={'center'}>
            <Text fontSize={'$5'} fontWeight={'bold'}>
              {category?.name ?? 'Uncategorized'}
            </Text>
            {transaction.merchant && (
              <Text fontSize={'$3'} color={'gray'}>
                {transaction.merchant}
              </Text>
            )}
          </View>
          <View marginLeft={'auto'} alignItems={'flex-end'}>
            <Text fontSize={'$5'} color={transaction.amount > 0 ? '$greenLight' : '$stroberiLight'}>
              {formatCurrency(transaction.amount, transaction.currencyCode)}
            </Text>
            <Text fontSize={'$3'} color={'gray'}>
              {date}
            </Text>
          </View>
        </View>
      </ReanimatedSwipeable>
    </YGroup.Item>
  );

  return (
    <ContextMenu.Root>
      <ContextMenu.Trigger>{component}</ContextMenu.Trigger>
      <ContextMenu.Content
        loop={false}
        collisionPadding={{}}
        alignOffset={true}
        avoidCollisions={true}>
        <ContextMenu.Preview>{() => component}</ContextMenu.Preview>
        <ContextMenu.Item key={'edit'} onSelect={onEdit}>
          <ContextMenu.ItemTitle>Edit</ContextMenu.ItemTitle>
        </ContextMenu.Item>
        <ContextMenu.Item key={'delete'} destructive onSelect={onDelete}>
          <ContextMenu.ItemTitle>Delete</ContextMenu.ItemTitle>
        </ContextMenu.Item>
      </ContextMenu.Content>
    </ContextMenu.Root>
  );
});

================
File: components/TransactionsList.tsx
================
import dayjs from 'dayjs';
import { DateFormats } from '../lib/date';
import { withObservables } from '@nozbe/watermelondb/react';
import { Database, Q } from '@nozbe/watermelondb';
import { Observable } from 'rxjs';
import { Text, YGroup } from 'tamagui';
import { TransactionItem } from './TransactionItem';
import * as React from 'react';
import { TransactionModel } from '../database/transaction-model';
import { CreateFirstTransactionButton } from './CreateFirstTransactionButton';
import { DateFilters } from '../app/(tabs)/transactions';
import { CategoryModel } from '../database/category-model';
import { SectionList } from 'react-native';
import { useSafeAreaInsets } from 'react-native-safe-area-context';

type TransactionsListProps = {
  transactions: TransactionModel[];
};

const getDateKey = (date: Date) => {
  const dayjsDate = dayjs(date);
  if (dayjsDate.isToday()) {
    return 'Today';
  }
  if (dayjsDate.isYesterday()) {
    return 'Yesterday';
  }
  return dayjsDate.format(
    dayjsDate.year() === dayjs().year()
      ? DateFormats.FullMonthFullDay
      : DateFormats.FullMonthFullDay + ', YYYY'
  );
};

const TransactionsList = ({ transactions }: TransactionsListProps) => {
  const { bottom } = useSafeAreaInsets();
  const sections = transactions.reduce(
    (acc, transaction) => {
      const key = getDateKey(transaction.date);
      const section = acc.find(section => section.title === key);
      if (section) {
        section.data.push(transaction);
      } else {
        acc.push({ title: key, data: [transaction] });
      }
      return acc;
    },
    [] as { title: string; data: TransactionModel[] }[]
  );

  if (transactions.length === 0) {
    return <CreateFirstTransactionButton mt={'30%'} />;
  }

  return (
    <YGroup>
      <SectionList
        contentInset={{
          bottom: 64 + bottom,
        }}
        sections={sections}
        keyExtractor={transaction => transaction.id}
        renderItem={({ item: transaction }) => (
          <TransactionItem
            date={dayjs(transaction.date).format(DateFormats.FullMonthFullDayTime)}
            transaction={transaction}
          />
        )}
        stickySectionHeadersEnabled={false}
        renderSectionHeader={({ section: { title } }) => (
          <Text fontSize={'$5'} fontWeight={'bold'} marginTop={'$4'} marginBottom={'$2'}>
            {title}
          </Text>
        )}
      />
    </YGroup>
  );
};

const enhance = withObservables<
  {
    database: Database;
    dateFilter?: DateFilters | null;
    customRange?: [Date, Date];
    categories: CategoryModel[];
  },
  { transactions: Observable<TransactionModel[]> }
>(
  ['dateFilter', 'customRange', 'categories'],
  ({ database, dateFilter, customRange, categories }) => {
    let query = database.collections
      .get<TransactionModel>('transactions')
      .query(Q.sortBy('date', 'desc'));

    if (dateFilter === 'This Year') {
      const startOfYear = dayjs().startOf('year').toDate();
      const endOfYear = dayjs().endOf('year').toDate();
      query = query.extend(Q.where('date', Q.gte(startOfYear.getTime())));
      query = query.extend(Q.where('date', Q.lte(endOfYear.getTime())));
    } else if (dateFilter === 'This Month') {
      const startOfMonth = dayjs().startOf('month').toDate();
      const endOfMonth = dayjs().endOf('month').toDate();
      query = query.extend(Q.where('date', Q.gte(startOfMonth.getTime())));
      query = query.extend(Q.where('date', Q.lte(endOfMonth.getTime())));
    } else if (customRange) {
      const [start, end] = customRange;
      query = query.extend(Q.where('date', Q.gte(start.getTime())));
      query = query.extend(Q.where('date', Q.lte(end.getTime())));
    }
    if (categories.length > 0) {
      query = query.extend(Q.where('categoryId', Q.oneOf(categories.map(c => c.id))));
    }
    return {
      transactions: query.observe(),
    };
  }
);

export default enhance(TransactionsList);

================
File: constants/Colors.ts
================
/**
 * Below are the colors that are used in the app. The colors are defined in the light and dark mode.
 * There are many other ways to style your app. For example, [Nativewind](https://www.nativewind.dev/), [Tamagui](https://tamagui.dev/), [unistyles](https://reactnativeunistyles.vercel.app), etc.
 */

const tintColorLight = '#0a7ea4';
const tintColorDark = '#fff';

export const Colors = {
  light: {
    text: '#11181C',
    background: '#fff',
    tint: tintColorLight,
    icon: '#687076',
    tabIconDefault: '#687076',
    tabIconSelected: tintColorLight,
  },
  dark: {
    text: '#ECEDEE',
    background: '#151718',
    tint: tintColorDark,
    icon: '#9BA1A6',
    tabIconDefault: '#9BA1A6',
    tabIconSelected: tintColorDark,
  },
};

================
File: data/currencies.ts
================
export type Currency = {
  name: string;
  code: string;
};
export const currencies: Currency[] = [
  { name: 'US Dollar', code: 'USD' },
  { name: 'Euro', code: 'EUR' },
  { name: 'British Pound', code: 'GBP' },
  { name: 'Japanese Yen', code: 'JPY' },
  { name: 'Chinese Yuan', code: 'CNY' },
  { name: 'Russian Ruble', code: 'RUB' },
  { name: 'Indian Rupee', code: 'INR' },
  { name: 'Brazilian Real', code: 'BRL' },
  { name: 'Mexican Peso', code: 'MXN' },
  { name: 'Australian Dollar', code: 'AUD' },
  { name: 'Canadian Dollar', code: 'CAD' },
  { name: 'Swiss Franc', code: 'CHF' },
  { name: 'South African Rand', code: 'ZAR' },
  { name: 'Swedish Krona', code: 'SEK' },
  { name: 'Norwegian Krone', code: 'NOK' },
  { name: 'South Korean Won', code: 'KRW' },
  { name: 'Turkish Lira', code: 'TRY' },
  { name: 'New Zealand Dollar', code: 'NZD' },
  { name: 'Singapore Dollar', code: 'SGD' },
  { name: 'Hong Kong Dollar', code: 'HKD' },
  { name: 'Polish Zloty', code: 'PLN' },
  { name: 'Danish Krone', code: 'DKK' },
  { name: 'Hungarian Forint', code: 'HUF' },
  { name: 'Czech Koruna', code: 'CZK' },
  { name: 'Israeli Shekel', code: 'ILS' },
  { name: 'Chilean Peso', code: 'CLP' },
  { name: 'Philippine Peso', code: 'PHP' },
  { name: 'UAE Dirham', code: 'AED' },
  { name: 'Colombian Peso', code: 'COP' },
  { name: 'Saudi Riyal', code: 'SAR' },
  { name: 'Malaysian Ringgit', code: 'MYR' },
  { name: 'Romanian Leu', code: 'RON' },
  { name: 'Indonesian Rupiah', code: 'IDR' },
  { name: 'Thai Baht', code: 'THB' },
  { name: 'Serbian Dinar', code: 'RSD' },
];

================
File: data/defaultCategories.ts
================
export const DEFAULT_CATEGORIES = [
  {
    name: 'Food',
    icon: '🍔',
  },
  {
    name: 'Transport',
    icon: '🚗',
  },
  {
    name: 'Entertainment',
    icon: '🎮',
  },
  {
    name: 'Health',
    icon: '🏥',
  },
  {
    name: 'Education',
    icon: '🎓',
  },
  {
    name: 'Utilities',
    icon: '💡',
  },
  {
    name: 'Shopping',
    icon: '🛍️',
  },
  {
    name: 'Travel',
    icon: '✈️',
  },
  {
    name: 'Other',
    icon: '📦',
  },
];

================
File: data/emojis.ts
================
export const spendingCategories = [
  '🍔',
  '🍕',
  '🍣',
  '🍜',
  '🍲', // Food & Dining
  '🛒',
  '🥦',
  '🍎',
  '🥚',
  '🥖', // Groceries
  '🚗',
  '🚌',
  '🚆',
  '✈️',
  '⛽', // Transportation
  '🏠',
  '🏡',
  '🏢',
  '🔑',
  '🏘️', // Housing
  '💡',
  '🔥',
  '💧',
  '📡',
  '📞', // Utilities
  '🎬',
  '🎮',
  '🎤',
  '🎧',
  '🎭', // Entertainment
  '🏥',
  '💊',
  '🩺',
  '👩‍⚕️',
  '🦷', // Healthcare
  '🛡️',
  '💇‍♀️',
  '💆‍♂️',
  '🛀',
  '🧴',
  '🧼', // Personal Care
  '👗',
  '👚',
  '👖',
  '👠',
  '👟', // Clothing
  '📚',
  '📝',
  '🏫',
  '🎓', // Education
  '💰',
  '📈',
  '🏦',
  '💳', // Savings & Investments
  '🎁',
  '🎉',
  '🎈',
  '🙏', // Gifts & Donations
  '🌍',
  '🗺️',
  '🏝️',
  '🚢', // Travel
  '🐶',
  '🐱',
  '🐾',
  '🐦', // Pets
];

================
File: data/transactions.ts
================
export const transactions = [
  {
    name: 'McDonalds',
    amount: '$12.99',
    date: 'Today',
    category: 'Food & Drink',
    icon: '🍔',
  },

  {
    name: 'Amazon',
    amount: '$99.99',
    date: 'Yesterday',
    category: 'Shopping',
    icon: '🛍️',
  },
  {
    name: 'Walmart',
    amount: '$49.99',
    date: 'Yesterday',
    category: 'Shopping',
    icon: '🛒',
  },
  {
    name: 'Starbucks',
    amount: '$4.99',
    date: 'Yesterday',
    category: 'Food & Drink',
    icon: '☕',
  },
  {
    name: 'Target',
    amount: '$29.99',
    date: 'Yesterday',
    category: 'Shopping',
    icon: '🎯',
  },
  {
    name: 'Best Buy',
    amount: '$199.99',
    date: 'Yesterday',
    category: 'Electronics',
    icon: '📺',
  },
  {
    name: 'Costco',
    amount: '$99.99',
    date: 'Yesterday',
    category: 'Shopping',
    icon: '🏪',
  },
  {
    name: 'Home Depot',
    amount: '$49.99',
    date: 'Yesterday',
    category: 'Shopping',
    icon: '🛠️',
  },
  {
    name: 'Subway',
    amount: '$9.99',
    date: 'Yesterday',
    category: 'Food & Drink',
    icon: '🥪',
  },
  {
    name: 'Chick-fil-A',
    amount: '$7.99',
    date: 'Yesterday',
    category: 'Food & Drink',
    icon: '🍗',
  },
  {
    name: 'KFC',
    amount: '$9.99',
    date: 'Yesterday',
    category: 'Food & Drink',
    icon: '🍗',
  },
  {
    name: 'Panda Express',
    amount: '$12.99',
    date: '5 days ago',
    category: 'Food & Drink',
    icon: '🍜',
  },
  {
    name: 'Apple',
    amount: '$999.99',
    date: '5 days ago',
    category: 'Electronics',
    icon: '📱',
  },
];

================
File: database/category-model.ts
================
import { Model } from '@nozbe/watermelondb';
import { date, readonly, text, writer } from '@nozbe/watermelondb/decorators';

export class CategoryModel extends Model {
  static table = 'categories';
  @text('name') name: string;
  @text('icon') icon: string;

  @readonly @date('created_at') createdAt: Date;
  @readonly @date('updated_at') updatedAt: Date;

  @writer deleteCategory() {
    return this.markAsDeleted();
  }

  @writer updateCategory({ name, icon }: { name: string; icon: string }) {
    return this.prepareUpdate(tx => {
      tx.name = name;
      tx.icon = icon;
    });
  }
}

================
File: database/helpers.ts
================
import { TransactionModel } from './transaction-model';
import { CategoryModel } from './category-model';
import { database } from './index';
import { getCurrencyConversion } from '../hooks/useCurrencyApi';

export type CreateTransactionPayload = {
  merchant: string;
  amount: number;
  categoryId: string | null;
  date: Date;
  currencyCode: string;
  note: string;
  baseCurrency: string;
};
export const createTransaction = ({
  merchant,
  amount,
  categoryId,
  date,
  currencyCode,
  note,
  baseCurrency,
}: CreateTransactionPayload) =>
  database.write(async () => {
    const collection = database.get<TransactionModel>('transactions');
    const categoryCollection = categoryId
      ? await database.get<CategoryModel>('categories').find(categoryId)
      : null;

    let baseCurrencyCode = baseCurrency;
    let amountInBaseCurrency = amount;
    let exchangeRate = 1;
    if (baseCurrency !== currencyCode) {
      const rate = await getCurrencyConversion(baseCurrency, currencyCode);
      if (rate) {
        baseCurrencyCode = baseCurrency;
        amountInBaseCurrency = amount * rate;
        exchangeRate = rate;
      }
    }

    return collection.create(tx => {
      tx.merchant = merchant;
      tx.amount = amount;
      tx.date = date;
      tx.currencyCode = currencyCode;
      tx.note = note;
      tx.baseCurrencyCode = baseCurrencyCode;
      tx.amountInBaseCurrency = amountInBaseCurrency;
      tx.exchangeRate = exchangeRate;
      if (categoryCollection) {
        tx.category?.set(categoryCollection);
      }
    });
  });

export const updateTransaction = ({
  id,
  merchant,
  amount,
  categoryId,
  date,
  currencyCode,
  note,
  baseCurrency,
}: {
  id: string;
  merchant: string;
  amount: number;
  categoryId: string | null;
  date: Date;
  currencyCode: string;
  note: string;
  baseCurrency: string;
}) =>
  database.write(async () => {
    const collection = database.get<TransactionModel>('transactions');
    const categoryCollection = categoryId
      ? await database.get<CategoryModel>('categories').find(categoryId)
      : null;
    const transaction = await collection.find(id);

    let baseCurrencyCode = baseCurrency;
    let amountInBaseCurrency = amount;
    let exchangeRate = 1;
    if (baseCurrency !== currencyCode) {
      const rate = await getCurrencyConversion(baseCurrency, currencyCode);
      if (rate) {
        baseCurrencyCode = baseCurrency;
        amountInBaseCurrency = amount * rate;
        exchangeRate = rate;
      }
    }

    return transaction.update(tx => {
      tx.merchant = merchant;
      tx.amount = amount;
      tx.date = date;
      tx.currencyCode = currencyCode;
      tx.note = note;
      tx.baseCurrencyCode = baseCurrencyCode;
      tx.amountInBaseCurrency = amountInBaseCurrency;
      tx.exchangeRate = exchangeRate;
      if (categoryCollection) {
        tx.category?.set(categoryCollection);
      }
    });
  });

export const createCategory = ({ name, icon }: { name: string; icon: string }) =>
  database.write(async () => {
    const collection = database.get<CategoryModel>('categories');
    return collection.create(category => {
      category.name = name;
      category.icon = icon;
    });
  });

================
File: database/index.ts
================
import { Database } from '@nozbe/watermelondb';
import SQLiteAdapter from '@nozbe/watermelondb/adapters/sqlite';
import { CategoryModel } from './category-model';
import { TransactionModel } from './transaction-model';
import { Platform } from 'react-native';
import { migrations } from './migrations';
import { schema } from './schema';

const adapter = new SQLiteAdapter({
  schema,
  jsi: Platform.OS === 'ios',
  migrations,
});

export const database = new Database({
  adapter,
  modelClasses: [TransactionModel, CategoryModel],
});

================
File: database/migrations.ts
================
import { schemaMigrations, addColumns } from '@nozbe/watermelondb/Schema/migrations';

export const migrations = schemaMigrations({
  migrations: [
    {
      toVersion: 7,
      steps: [
        addColumns({
          table: 'transactions',
          columns: [{ name: 'note', type: 'string' }],
        }),
      ],
    },
    {
      toVersion: 8,
      steps: [
        addColumns({
          table: 'transactions',
          columns: [
            { name: 'baseCurrencyCode', type: 'string' },
            { name: 'amountInBaseCurrency', type: 'number' },
            { name: 'exchangeRate', type: 'number' },
          ],
        }),
      ],
    },
  ],
});

================
File: database/schema.ts
================
import { appSchema, tableSchema } from '@nozbe/watermelondb';

export const schema = appSchema({
  version: 8,
  tables: [
    tableSchema({
      name: 'transactions',
      columns: [
        { name: 'merchant', type: 'string' },
        { name: 'note', type: 'string' },
        { name: 'amount', type: 'number' },
        { name: 'created_at', type: 'number' },
        { name: 'updated_at', type: 'number' },
        { name: 'date', type: 'number' },
        { name: 'currencyCode', type: 'string' },
        { name: 'categoryId', type: 'string', isOptional: true },
        { name: 'baseCurrencyCode', type: 'string' },
        { name: 'amountInBaseCurrency', type: 'number' },
        { name: 'exchangeRate', type: 'number' },
      ],
    }),
    tableSchema({
      name: 'categories',
      columns: [
        { name: 'name', type: 'string' },
        { name: 'icon', type: 'string' },
        { name: 'created_at', type: 'number' },
        { name: 'updated_at', type: 'number' },
      ],
    }),
  ],
});

================
File: database/transaction-model.ts
================
import { Model, Relation } from '@nozbe/watermelondb';
import { field, readonly, relation, text, writer, date } from '@nozbe/watermelondb/decorators';
import { CategoryModel } from './category-model';
import { Associations } from '@nozbe/watermelondb/Model';

export class TransactionModel extends Model {
  static table = 'transactions';
  static associations: Associations = {
    categories: {
      key: 'id',
      type: 'belongs_to',
    },
  };

  @text('merchant') merchant: string;
  @text('note') note: string;
  @text('currencyCode') currencyCode: string; // Existing field for original currency
  @field('amount') amount: number; // Original amount in the transaction's currency
  @text('baseCurrencyCode') baseCurrencyCode: string; // New field for the base currency
  @field('amountInBaseCurrency') amountInBaseCurrency: number; // New field for amount in base currency
  @field('exchangeRate') exchangeRate: number; // New field for the exchange rate used

  @date('date') date: Date;

  @relation('categories', 'categoryId') category: Relation<CategoryModel> | null;

  @readonly @date('created_at') createdAt: Date;
  @readonly @date('updated_at') updatedAt: Date;

  @writer deleteTx() {
    return this.markAsDeleted();
  }
}

================
File: hooks/useCurrencyApi.ts
================
import { database } from '../database';

const CACHE_KEY_PREFIX = 'currency_conversion_cache_';
const CACHE_TIMESTAMP_KEY_PREFIX = 'currency_conversion_cache_timestamp_';
const CACHE_EXPIRY_MS = 24 * 60 * 60 * 1000; // 24 hours

export const getCurrencyConversion = async (baseCurrency: string, targetCurrency: string) => {
  const cacheKey = `${CACHE_KEY_PREFIX}${baseCurrency}_${targetCurrency}`;
  const fetchFromApi = async (url: string) => {
    const response = await fetch(url);
    const data = await response.json();
    return data[targetCurrency.toLowerCase()][baseCurrency.toLowerCase()];
  };

  const getCachedData = async (key: string) => {
    const cachedData = await database.localStorage.get(key);
    const cachedTimestamp = Number(
      (await database.localStorage.get(CACHE_TIMESTAMP_KEY_PREFIX)) ?? 0
    );
    if (cachedData && cachedTimestamp && Date.now() - cachedTimestamp < CACHE_EXPIRY_MS) {
      return JSON.parse(cachedData as string);
    }
    return null;
  };

  const setCachedData = async (data: number) => {
    await database.localStorage.set(CACHE_TIMESTAMP_KEY_PREFIX, Date.now());
    await database.localStorage.set(cacheKey, JSON.stringify(data));
  };

  const cachedData = await getCachedData(cacheKey);
  if (cachedData) {
    return cachedData;
  }

  try {
    const primaryUrl = `https://cdn.jsdelivr.net/npm/@fawazahmed0/currency-api@latest/v1/currencies/${targetCurrency.toLowerCase()}.json`;
    const data = await fetchFromApi(primaryUrl);
    await setCachedData(data);
    return data;
  } catch (error) {
    console.error('Error fetching from primary API, trying fallback:', error);
    try {
      const fallbackUrl = `https://currency-api.pages.dev/v1/currencies/${targetCurrency.toLowerCase()}.json`;
      const data = await fetchFromApi(fallbackUrl);
      await setCachedData(data);
      return data;
    } catch (fallbackError) {
      console.error('Error fetching from fallback API:', fallbackError);
      return null;
    }
  }
};

================
File: hooks/useDefaultCurrency.ts
================
import { useEffect, useState } from 'react';
import { database } from '../database';
import { getLocales } from 'expo-localization';
import { getCurrencyConversion } from '../hooks/useCurrencyApi';
import { TransactionModel } from '../database/transaction-model';

export const useDefaultCurrency = () => {
  const [defaultCurrency, setDefaultCurrency] = useState<string | null>(null);

  useEffect(() => {
    database.localStorage.get('defaultCurrency').then(currency => {
      if (!currency) {
        const [locale] = getLocales();
        if (locale.currencyCode) {
          // set some default currency
          database.localStorage.set('defaultCurrency', locale.currencyCode);
        }
      } else if (typeof currency === 'string') {
        setDefaultCurrency(currency);
      }
    });
  }, []);

  const updateTransactionsCurrency = async (newBaseCurrency: string) => {
    const transactionsCollection = database.collections.get<TransactionModel>('transactions');
    const transactions = await transactionsCollection.query().fetch();

    await database.write(async () => {
      for (const transaction of transactions) {
        const { currencyCode, amount } = transaction;
        const exchangeRate = await getCurrencyConversion(newBaseCurrency, currencyCode);

        if (exchangeRate) {
          await transaction.update(record => {
            record.baseCurrencyCode = newBaseCurrency;
            record.amountInBaseCurrency = amount * exchangeRate;
            record.exchangeRate = exchangeRate;
          });
        }
      }
    });
  };

  const handleSetDefaultCurrency = async (currency: string) => {
    await database.localStorage.set('defaultCurrency', currency);
    setDefaultCurrency(currency);
    await updateTransactionsCurrency(currency);
  };

  return {
    defaultCurrency,
    setDefaultCurrency: handleSetDefaultCurrency,
  };
};

================
File: hooks/useSeedCategories.tsx
================
import { useEffect } from 'react';
import { database } from '../database';
import { CategoryModel } from '../database/category-model';
import { DEFAULT_CATEGORIES } from '../data/defaultCategories';

export const useSeedCategories = () => {
  useEffect(() => {
    (async () => {
      const categories = await database.collections
        .get<CategoryModel>('categories')
        .query()
        .fetch();
      if (categories.length === 0) {
        await database.write(async () => {
          for (const category of DEFAULT_CATEGORIES) {
            await database.collections.get<CategoryModel>('categories').create(newCategory => {
              newCategory.name = category.name;
              newCategory.icon = category.icon;
            });
          }
        });
      }
    })();
  }, []);
};

================
File: hooks/useThemeColor.ts
================
/**
 * Learn more about light and dark modes:
 * https://docs.expo.dev/guides/color-schemes/
 */

import { useColorScheme } from 'react-native';
import { Colors } from '../constants/Colors';

export function useThemeColor(
  props: { light?: string; dark?: string },
  colorName: keyof typeof Colors.light & keyof typeof Colors.dark
) {
  const theme = useColorScheme() ?? 'light';
  const colorFromProps = props[theme];

  if (colorFromProps) {
    return colorFromProps;
  } else {
    return Colors[theme][colorName];
  }
}

================
File: hooks/useToast.ts
================
import * as Burnt from 'burnt';
import type { SFSymbol } from 'sf-symbols-typescript';
import { AlertOptions } from 'burnt/build/types';

export interface IconParams {
  ios: {
    /**
     * The name of an iOS-only SF Symbol. For a full list, see https://developer.apple.com/sf-symbols/.
     * @platform ios
     */
    name: SFSymbol | string;
    /**
     * Change the custom icon color, default is system blue.
     * @platform ios
     */
    color: string;
  };
  web?: JSX.Element;
}

interface BurntCroutonProps {
  title: string;
  message?: string;
  preset?: 'error' | 'done' | 'none' | 'custom';
  duration?: number;
  haptic?: 'success' | 'warning' | 'error' | 'none';
  shouldDismissByDrag?: boolean;
  from?: 'top' | 'bottom';
  layout?: {
    iconSize?: {
      height: number;
      width: number;
    };
  };
  icon?: IconParams;
}

const useToast = () => {
  const show = async (props: BurntCroutonProps) => {
    const {
      title,
      message,
      preset = 'done',
      duration = 2,
      haptic = 'none',
      shouldDismissByDrag = true,
      from = 'top',
      layout = {
        iconSize: {
          height: 24,
          width: 24,
        },
      },
      icon = {
        ios: {
          name: 'checkmark.seal',
          color: 'hsl(151, 50.0%, 53.2%)',
        },
      },
    } = props;

    Burnt.toast({
      title,
      message,
      preset,
      duration,
      haptic,
      shouldDismissByDrag,
      from,
      layout,
      icon,
    });
  };
  const alert = (props: AlertOptions) => {
    Burnt.alert({
      preset: 'done', // or "error", "heart", "custom"
      message: '', // optional
      duration: 8, // duration in seconds
      layout: {
        iconSize: {
          height: 18,
          width: 18,
        },
      },
      // @ts-expect-error ignore
      icon: {
        ios: {
          // SF Symbol. For a full list, see https://developer.apple.com/sf-symbols/.
          name: 'checkmark.seal',
          color: '#1D9BF0',
        },
      },
      ...props,
    });
  };

  return {
    show,
    alert,
  };
};

export default useToast;

================
File: lib/date.ts
================
import dayjs from 'dayjs';

export enum DateFormats {
  FullMonthFullDay = 'MMM DD',
  FullMonthFullDayTime = 'MMM DD HH:mm',
}

export function formatDateRange(from: dayjs.Dayjs, to: dayjs.Dayjs): string {
  if (from.date() === 1 && to.date() === to.daysInMonth() && from.isSame(to, 'month')) {
    return from.format('MMM YYYY');
  } else if (from.isSame(to, 'year')) {
    return `${from.format('MMM D')} - ${to.format('MMM D, YYYY')}`;
  } else {
    return `${from.format('MMM D, YYYY')} - ${to.format('MMM D, YYYY')}`;
  }
}

================
File: lib/format.ts
================
export const formatCurrency = (value: number, currency: string) =>
  new Intl.NumberFormat('en-US', {
    style: 'currency',
    currency: currency,
  }).format(value);

export const formatCurrencyWorklet = (value: number, currency: string) => {
  'worklet';
  return new Intl.NumberFormat('en-US', {
    style: 'currency',
    currency: currency,
  }).format(value);
};

================
File: .gitignore
================
# @generated expo-cli sync-2b81b286409207a5da26e14c78851eb30d8ccbdb
# The following patterns were generated by expo-cli

expo-env.d.ts
# @end expo-cli

# keep types in repo to track them
# **/types/**/*.d.ts
# but map can be ignored and just published on npm
**/types/**/*.d.ts.map

.yarn/*
!.yarn/patches
!.yarn/plugins
!.yarn/releases
!.yarn/sdks
!.yarn/versions

.turbo

.ultra.cache.json
tmp
*.tsbuildinfo
*.tmp.js
yarn-error.log
dist
tsconfig.tsbuildinfo
node_modules
**/_
**/tests/spec/out
.DS_Store

.next

.vercel

apps/site/out
apps/kitchen-sink/ios

.tamagui

.idea

.env
# local env files
.env.local
.env.development.local
.env.test.localp
.env.production.local

apps/kitchen-sink/ios
apps/kitchen-sink/android

# ignore until videos finalized
apps/site/public/talk/

apps/studio/types/**

.expo

================
File: .nvmrc
================
v20.4.0

================
File: .prettierrc
================
{
  "printWidth": 100,
  "tabWidth": 2,
  "singleQuote": true,
  "bracketSameLine": true,
  "trailingComma": "es5",
  "arrowParens": "avoid"
}

================
File: .prettierrc.js
================
module.exports = {
  singleQuote: true,
  endOfLine: 'auto',
};

================
File: .repomixignore
================
# Add patterns to ignore here, one per line
# Example:
# *.log
# tmp/
android
ios
node_modules
.idea
.tamagui
.yarn
tamagui-web.css

================
File: .yarnrc.yml
================
compressionLevel: mixed

enableGlobalCache: false

enableTelemetry: false

logFilters:
  - code: YN0002
    level: discard
  - code: YN0060
    level: discard
  - code: YN0006
    level: discard
  - code: YN0076
    level: discard

nodeLinker: node-modules

yarnPath: .yarn/releases/yarn-4.0.2.cjs

================
File: app.json
================
{
  "expo": {
    "name": "Stroberi",
    "slug": "stroberi",
    "version": "1.0.0",
    "orientation": "portrait",
    "icon": "./assets/images/icon.png",
    "scheme": "myapp",
    "userInterfaceStyle": "automatic",
    "assetBundlePatterns": [
      "**/*"
    ],
    "ios": {
      "supportsTablet": true,
      "bundleIdentifier": "com.stroberi"
    },
    "android": {
      "package": "com.dev.stroberi"
    },
    "web": {
      "bundler": "metro",
      "output": "static"
    },
    "plugins": [
      "expo-router",
      "expo-font",
      [
        "@morrowdigital/watermelondb-expo-plugin", { "disableJsi": true }
      ],
      [
        "expo-build-properties",
        {
          "android": {
            "kotlinVersion": "1.8.10",
            "packagingOptions": {
              "pickFirst": [
                "**/libc++_shared.so"
              ]
            }
          },
          "ios": {
            "deploymentTarget": "15.1"
          }
        }
      ],
      [
        "expo-document-picker",
        {
          "iCloudContainerEnvironment": "Production"
        }
      ],
      "expo-localization",
      [
        "expo-splash-screen",
        {
          "image": "./assets/images/splash2.png",
          "resizeMode": "contain",
          "backgroundColor": "#E54B4B",
          "imageWidth": 250
        }
      ],
      "expo-sqlite"
    ],
    "experiments": {
      "typedRoutes": true
    },
    "extra": {
      "router": {
        "origin": false
      },
      "eas": {
        "projectId": "f50955a8-0565-4300-8310-031161d5a861"
      }
    },
    "owner": "gacevicdanilo18"
  }
}

================
File: babel.config.js
================
module.exports = api => {
  api.cache(true);
  return {
    presets: ['babel-preset-expo'],
  };
};

================
File: biome.json
================
{
  "$schema": "https://biomejs.dev/schemas/1.5.1/schema.json",
  "organizeImports": {
    "enabled": false
  },
  "linter": {
    "enabled": true,
    "rules": {
      "correctness": {
        "useExhaustiveDependencies": "off",
        "noInnerDeclarations": "off",
        "noUnnecessaryContinue": "off",
        "noConstructorReturn": "off"
      },
      "suspicious": {
        "noImplicitAnyLet": "off",
        "noConfusingVoidType": "off",
        "noEmptyInterface": "off",
        "noExplicitAny": "off",
        "noArrayIndexKey": "off",
        "noDoubleEquals": "off",
        "noConsoleLog": "error",
        "noAssignInExpressions": "off",
        "noRedeclare": "off"
      },
      "style": {
        "noParameterAssign": "off",
        "noNonNullAssertion": "off",
        "noArguments": "off",
        "noUnusedTemplateLiteral": "off",
        "useDefaultParameterLast": "off",
        "useConst": "off",
        "useEnumInitializers": "off",
        "useTemplate": "off",
        "useSelfClosingElements": "off"
      },
      "security": {
        "noDangerouslySetInnerHtml": "off",
        "noDangerouslySetInnerHtmlWithChildren": "off"
      },
      "performance": {
        "noDelete": "off",
        "noAccumulatingSpread": "off"
      },
      "complexity": {
        "noForEach": "off",
        "noBannedTypes": "off",
        "useLiteralKeys": "off",
        "useSimplifiedLogicExpression": "off",
        "useOptionalChain": "off"
      },
      "a11y": {
        "noSvgWithoutTitle": "off",
        "useMediaCaption": "off",
        "noHeaderScope": "off",
        "useAltText": "off",
        "useButtonType": "off"
      }
    }
  },
  "formatter": {
    "enabled": true,
    "formatWithErrors": false,
    "indentStyle": "space",
    "indentWidth": 2,
    "lineWidth": 90,
    "ignore": ["**/*/generated-new.ts", "**/*/generated-v2.ts"]
  },
  "javascript": {
    "formatter": {
      "trailingComma": "es5",
      "jsxQuoteStyle": "double",
      "semicolons": "asNeeded",
      "quoteStyle": "single"
    }
  }
}

================
File: eas.json
================
{
  "build": {
    "development": {
      "developmentClient": true,
      "distribution": "internal"
    },
    "preview": {
      "distribution": "internal"
    },
    "production": {
    },
    "development-simulator": {
      "developmentClient": true,
      "distribution": "internal",
      "ios": {
        "simulator": true
      }
    }
  }
}

================
File: eslint.config.mjs
================
import globals from 'globals';
import pluginJs from '@eslint/js';
import tseslint from 'typescript-eslint';
import eslintConfigPrettier from "eslint-config-prettier";
import eslintPluginPrettierRecommended from 'eslint-plugin-prettier/recommended';

export default [
  { languageOptions: { globals: globals.browser } },
  pluginJs.configs.recommended,
  ...tseslint.configs.recommended,
  eslintConfigPrettier,
  eslintPluginPrettierRecommended
];

================
File: main.d.ts
================
// declare ttf as files
declare module '*.ttf' {
  const value: string;
  export default value;
}

================
File: metro.config.js
================
// Learn more https://docs.expo.io/guides/customizing-metro
const { getDefaultConfig } = require('expo/metro-config');

/** @type {import('expo/metro-config').MetroConfig} */
let config = getDefaultConfig(__dirname, {
  // [Web-only]: Enables CSS support in Metro.
  isCSSEnabled: false,
});

// 2. Enable Tamagui
const { withTamagui } = require('@tamagui/metro-plugin');
module.exports = withTamagui(config, {
  components: ['tamagui'],
  config: './tamagui.config.ts',
  outputCSS: './tamagui-web.css',
});

// REMOVE THIS (just for tamagui internal devs to work in monorepo):
// if (process.env.IS_TAMAGUI_DEV && __dirname.includes('tamagui')) {
//   const fs = require('fs')
//   const path = require('path')
//   const projectRoot = __dirname
//   const monorepoRoot = path.resolve(projectRoot, '../..')
//   config.watchFolders = [monorepoRoot]
//   config.resolver.nodeModulesPaths = [
//     path.resolve(projectRoot, 'node_modules'),
//     path.resolve(monorepoRoot, 'node_modules'),
//   ]
//   // have to manually de-deupe
//   try {
//     fs.rmSync(path.join(projectRoot, 'node_modules', '@tamagui'), {
//       recursive: true,
//       force: true,
//     })
//   } catch {}
//   try {
//     fs.rmSync(path.join(projectRoot, 'node_modules', 'tamagui'), {
//       recursive: true,
//       force: true,
//     })
//   } catch {}
//   try {
//     fs.rmSync(path.join(projectRoot, 'node_modules', 'react'), {
//       recursive: true,
//       force: true,
//     })
//   } catch {}
//   try {
//     fs.rmSync(path.join(projectRoot, 'node_modules', 'react-dom'), {
//       recursive: true,
//       force: true,
//     })
//   } catch {}
// }

================
File: package.json
================
{
  "name": "stroberi",
  "main": "expo-router/entry",
  "version": "1.0.0",
  "scripts": {
    "upgrade:tamagui": "yarn up '*tamagui*'@latest '@tamagui/*'@latest",
    "upgrade:tamagui:canary": "yarn up '*tamagui*'@canary '@tamagui/*'@canary",
    "start": "expo start",
    "android": "expo run:android",
    "ios": "expo run:ios",
    "web": "expo start --web",
    "test": "jest --watchAll",
    "lint": "eslint . "
  },
  "jest": {
    "preset": "jest-expo"
  },
  "dependencies": {
    "@expo/metro-runtime": "~4.0.0",
    "@expo/react-native-action-sheet": "^4.1.0",
    "@gorhom/bottom-sheet": "^5.0.2",
    "@morrowdigital/watermelondb-expo-plugin": "^2.3.3",
    "@nozbe/simdjson": "^3.1.0-wmelon1",
    "@nozbe/watermelondb": "^0.27.1",
    "@react-native-community/datetimepicker": "8.2.0",
    "@react-native-menu/menu": "^1.1.7",
    "@react-navigation/bottom-tabs": "^7.0.0",
    "@react-navigation/native": "^7.0.0",
    "@shopify/react-native-skia": "1.5.0",
    "@tamagui/config": "^1.98.0",
    "@tamagui/lucide-icons": "^1.98.0",
    "@tamagui/metro-plugin": "^1.98.0",
    "@tamagui/portal": "^1.100.3",
    "@tamagui/select": "^1.100.3",
    "@tamagui/sheet": "^1.100.3",
    "babel-preset-expo": "~12.0.0",
    "burnt": "^0.12.2",
    "dayjs": "^1.11.13",
    "expo": "^52.0.11",
    "expo-blur": "~14.0.1",
    "expo-build-properties": "~0.13.1",
    "expo-dev-client": "~5.0.4",
    "expo-document-picker": "~13.0.1",
    "expo-file-system": "~18.0.4",
    "expo-font": "~13.0.1",
    "expo-linear-gradient": "~14.0.1",
    "expo-linking": "~7.0.3",
    "expo-localization": "~16.0.0",
    "expo-router": "~4.0.9",
    "expo-sharing": "~13.0.0",
    "expo-splash-screen": "~0.29.13",
    "expo-sqlite": "~15.0.3",
    "expo-status-bar": "~2.0.0",
    "expo-system-ui": "~4.0.4",
    "expo-web-browser": "~14.0.1",
    "papaparse": "^5.4.1",
    "react": "18.3.1",
    "react-dom": "18.3.1",
    "react-native": "0.76.3",
    "react-native-gesture-handler": "~2.20.2",
    "react-native-ios-context-menu": "^2.5.2",
    "react-native-ios-utilities": "^4.5.1",
    "react-native-keyboard-controller": "^1.14.5",
    "react-native-reanimated": "~3.16.1",
    "react-native-reanimated-carousel": "v4.0.0-alpha.12",
    "react-native-safe-area-context": "4.12.0",
    "react-native-screens": "~4.1.0",
    "react-native-svg": "15.8.0",
    "react-native-web": "~0.19.13",
    "tamagui": "^1.98.0",
    "typescript": "^5.3.3",
    "victory-native": "^41.12.5",
    "zeego": "^1.10.0"
  },
  "devDependencies": {
    "@babel/core": "^7.25.2",
    "@eslint/js": "^9.2.0",
    "@react-native-community/cli": "^15.1.2",
    "@types/papaparse": "^5",
    "@types/react": "~18.3.12",
    "eslint": "^9.2.0",
    "eslint-config-prettier": "^9.1.0",
    "eslint-config-universe": "^12.1.0",
    "eslint-plugin-prettier": "^5.1.3",
    "eslint-plugin-react": "^7.34.1",
    "globals": "^15.2.0",
    "prettier": "^3.2.5",
    "repomix": "^0.2.6",
    "typescript-eslint": "^7.9.0"
  },
  "private": true,
  "packageManager": "yarn@4.0.2"
}

================
File: README.md
================
# Stroberi (wip)
<img src="./assets/images/icon.png" alt="drawing" width="100"/>

Open-source personal expense tracking app built with React Native. It helps you manage your finances by tracking your expenses and categorizing them.
It's privary first, so your data is stored locally on your device and never leaves it.
## Features

- Track daily expenses
- Categorize expenses
- Export and import data in CSV format
- Manage categories
- Set default currency

## Technologies Used

- TypeScript
- React
- React Native
- SQLite
- Tamagui
- Bottom Sheet Modal
- Yarn



## Local development

```
yarn start
```

```
npx expo prebuild
```

================
File: repomix.config.json
================
{
  "output": {
    "filePath": "repomix-output.txt",
    "style": "plain",
    "removeComments": false,
    "removeEmptyLines": false,
    "topFilesLength": 5,
    "showLineNumbers": false,
    "copyToClipboard": false
  },
  "include": [],
  "ignore": {
    "useGitignore": true,
    "useDefaultPatterns": true,
    "customPatterns": []
  },
  "security": {
    "enableSecurityCheck": true
  }
}

================
File: tamagui.config.ts
================
import { config } from '@tamagui/config/v3';

import { createTamagui, createTokens } from 'tamagui';

const tokens = createTokens({
  ...config.tokens,
  color: {
    ...config.tokens.color,
    stroberi: '#E54B4B',
    brandPrimary: '#E54B4B',
    brandSecondary: '#FFA987',
    bgPrimary: 'black',
    seashell: '#F7EBE8',
    green: 'hsl(151, 50.0%, 53.2%)',
    greenLight: 'hsl(151, 50.0%, 70.2%)',
    stroberiLight: 'rgb(215,99,80)',
  },
});
export const tamaguiConfig = createTamagui({
  ...config,
  tokens,
  themes: {
    ...config.themes,
    dark: {
      ...config.themes.dark,
      stroberi: tokens.color.stroberi,
      bgPrimary: tokens.color.bgPrimary,
      brandPrimary: tokens.color.brandPrimary,
      brandSecondary: tokens.color.brandSecondary,
      seashell: tokens.color.seashell,
      green: tokens.color.green,
      greenLight: tokens.color.greenLight,
      stroberiLight: tokens.color.stroberiLight,
    },
  },
});
export default tamaguiConfig;
export type Conf = typeof tamaguiConfig;
declare module 'tamagui' {
  interface TamaguiCustomConfig extends Conf {}
}

================
File: tsconfig.json
================
{
  "extends": "expo/tsconfig.base",
  "compilerOptions": {
    "strict": true,
    "emitDecoratorMetadata": true,
    "experimentalDecorators": true,
    "strictPropertyInitialization": false
  },
  "include": ["**/*.ts", "**/*.tsx", ".expo/types/**/*.ts", "expo-env.d.ts"]
}
